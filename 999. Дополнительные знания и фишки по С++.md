# 1. Ключевое слово `const` и его действие

Ключевое слово `const`, описывающее константность объектов кода, в С++ используется не только в качестве маркера константности элементов (например, переменных), но и для описания константности функций. 

Об этом действии ключевого слова будет описано в одной из глав энциклопедии, здесь же мы рассмотрим унифицированную для всех элементов область действия ключевого слова. Действие `const` распространяется на ***ближайший слева*** элемент, к которому он применим. Если `const` описано самым левым словом, его применение распространяется на самый левый "применяющий константность" элемент. К ссылкам `const` **не** применим, поскольку ссылка по своей природе не является изменяемым объектом (а вот тип ссылки поддерживает константность; поэтому могут быть ссылки на переменные обычных типов или на переменные константных типов)


```cpp
const A a; // константный тип А
A const b; // константный тип А
A const * c; // изменяемый указатель на константный тип А
A* const d; // константный указатель на изменяемый тип А
```

# 2. Некоторые особенности С++11

В курсе СП изучается, вообще говоря, стандарт С++98. Однако задания практикума пишутся и решаются стандартами более высокого уровня. Вот несколько полезных вещей, добавленных в стандарт С++11:

 + Объект `nullptr` - нулевой указатель, не приводящийся к целочисленным типам, поскольку базируется на указательной структуре, а не на числовой (как `NULL`):
```cpp
f(char*);
f(int);

int main() {
    f(NULL); // f(int)
    f(nullptr); // f(char*)
}
```

 + rvalue-ссылка - (достаточно грубое упрощение в рамках курса: на деле это более тонкий по структуре и свойствам объект) позволяет сохранять и работать с rvalue-значениями; примером таких значений могут выступать, например, возвращаемые по значению (а не по обычной ссылке) значения функций.
```cpp
X a;
X f();
X& r1 = a;
X&& rr1 = f();
```

   На основе rvalue-ссылок можно создавать **конструкторы переноса**:
```cpp
String(String&& v) { // конструктор переноса
    str = v.str;
    len = v.len;
    v.str = nullptr; //!
} 

String f() {
    String a, b;
    
    /**/

    return a + b; // тк есть конструктор переноса, компилятор просто передаст указатель на динамическую память временного объекта, а не создаст новую - скопирует - удалит старую
}
```