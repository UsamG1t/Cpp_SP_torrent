Механизм исключений - логичное продолжение ООП на механизм обработки ошибок. Исключения - тоже объекты, какие-то из них принадлежат специальным классам встроенных исключений, однако, вообще говоря, механизм исключений не фиксирует набор объектов, с которым работает, а лишь описывает технологию обработки.

В механизме обработки исключений используются три ключевых слова: `try`, `throw`, `catch`. \
Ключевое слово `try` описывает отдельный блок кода, в рамках которого могут генерироваться исключения, которые после этого **на данном уровне вложенности** будут искать обработку. 
	Вообще говоря, исключения можно генерировать и вне `try`-блока. В таком случае объект исключения ищет ближайший `try`-блок на внешних фреймах (исключение вылетает из функций вверх по стеку в поисках). В случае отсутствия такого блока даже на самом верхнем уровне (в `main`), исключение вызовет экстренное завершение программы и выброс информации о нём.
Ключевое слово `throw` - основной и единственный генератор исключений из любого объекта.
Ключевое слово `catch` описывает обработчики исключений. Если тип аргумента `catch` способен "поймать" объект исключение, происходит его обработка. При этом внутри обработчика также может быть использовано ключевое слово `throw`, в таком случае исключение (новое или текущее) будет выброшено дальше.

```cpp
try {
	// Блок кода, потенциально генерирующий исключения
	B& rb = dynamic_cast<B&>(ra); // Неявно (внутри функции где-то с каким-то условием прописан throw)
	throw "abc"; // явно
}
catch(bad_cast){} // Описание отлавливаемого объекта может быть через указание его самого
catch(int){} // Через указание только типа - тогда исключение в обработчик прилетает анонимно, с ним внутри нельзя будет работать
catch(double d){} // Можно отлавливать с указанием имени и использовать в обработке внутри
catch(B&){} // Исключение можно отлавливать по значению или по ссылке. В случае отлова по значению на время обработки будет создаваться копия исключения, при отлове по ссылке - нет
catch(A&){} // Обработчик базового класса может перехватывать обработку объекта произвольного класса. Так как проверка соответствия ведётся поочерёдно до первой возможности обработки, обработчики базового класса необходимо писать после обработчиков проивольного
catch(...){} // обработчик с троеточием отлавливает любое исключение
```

***Механизм обработки исключений:***\
`В процессе описания механизма будут использованы аналогии прошлых лет. Автор не ручается за формальные названия всех элементов механизма, однако передаст суть и логику алгоритма.`

Механизм запускается при встрече ключевого слова `throw`.
1. Создаётся **основная копия исключения** ("антресолька"). При это если `throw` выбрасывает временный объект, сначала он создаётся, затем **копируется**, после уничтожается, а основная копия исключения сохраняется;
2. Происходит выход из `try`-блока. Если на данном уровне стека (в данной функции) его нет, происходит выброс во внешний фрейм и выход из `try`-блока там и т.д. При этом при выходе из очередного фрейма и при выходе из `try`-блока уничтожаются все объекты, в них до возникновения исключения созданные (недоработавший конструктор **не** генерирует объект). Весь код и все объекты фреймов и `try`-блока **после** исключения не отрабатывают;
3. На уровне выхода из `try`-блока проводится поиск подходящих обработчиков. В случае отсутствия обработчика, способного обработать исключение, происходит выброс на фрейм выше во внешний `try`-блок аналогично п.2.
4. При наличии обработчика проверяется способ передачи аргумента в него. 
   Если обработчик принимает исключение **по значению**, то создаётся **рабочая копия основной копии исключения** (копия "антресольки"), которая и обрабатывается в обработчике (если обработчик принимает анонимное исключение по значению, копия всё равно создаётся, просто также не используется). По завершении обработки (по любым причинам: новому исключению или корректному завершению обработки) рабочая копия удаляется. Основная копия ("антресолька") **никак** не меняется и не задействуется. 
   Если обработчик принимает исключение **по ссылке**, в обработчике используется именно основная копия ("антресолька").
5. В случае наличия в обработчике ключевого слова `throw`:
	1. Если ключевое слово `throw` указано **без параметра исключения**, происходит **выход из обработчика** (соответственно, оставшийся код недорабатывает, все созданные в нём объекты (включая рабочую копию (копию "антресольки"), если она была)) и происходит выход в объемлющий  `try`-блок аналогично п.2 (основная копия ("антресолька") **никак** не меняется)
	2. Если ключевое слово `throw` указано **с новым исключением**, сначала происходит **выход из обработчика** (соответственно, оставшийся код недорабатывает, все созданные в нём объекты (включая рабочую копию (копию "антресольки"), если она была)), затем **удаление основной копии** исключения ("антресольки"), создание **новой основной копии исключения** (новой "антресольки"), после чего происходит выход в объемлющий `try`-блок аналогично п.2
6. В случае корректного завершения обработки после удаления всех локальных объектов обработчика (включая рабочую копию (копию "антресольки"), если она была) удаляется основная копия ("антресолька")

```cpp
#include <iostream>

struct A {
    static int a;
    int b;
    A() {++a; b = a; std::cout << "Hello! " << b << std::endl;}
    A(const A& other) {b = other.b + 1; std::cout << "Copy " << b << std::endl;}
    ~A() {std::cout << "Bye! " << b << std::endl;}
};

int A::a = 0;

int main () { 
    A o1; // Hello 1

    try {
        try{
            throw o1; // Copy 2
        }
        catch(int) {}
        catch(A o2) {std::cout << "A o2 " << o2.b << std::endl; throw 15; } // Copy 3 | A o2 3 | Bye! 3 | Bye! 2
    }
    catch(int) { std::cout << "Catch int" << std::endl; } // Catch int

    return 0;
} // Bye! 1

```