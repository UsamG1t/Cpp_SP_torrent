Поговорим о ключевых отличиях (пока не так сильно вдаваясь в подробности некоторых вещей, о которых будем говорить в будущем) С++ от С.  Здесь описана лишь малая часть отличий, с которыми чаще всего будут происходить столкновения в процессе работы.

---

Самым первым и главным отличием языков стала поддержка в С++ парадигмы ***Объектно-Ориентированного Программирования***. Язык и взаимодействия в нём (даже привычные переменные и обычные операции над ними) теперь осуществляются с позиции взаимодействия **объектов** путём использования их **методов** и работы с их **полями**.
 
Чтобы реализовать ООП, в языке должны быть представлены ***3 основные его \[ООП\] состовляющие***:
 + **Инкапсуляция** - объединение данных и методов, работающих с этими данными (`private` данные, `public` методы в одном объекте)
 + **Полиморфизм** - использование одного и того же интерфейса для похожих действий у разных типов
   В С++ встречаются три типа полиморфизма:
   1. _Статический_ (разрешается на уровне компиляции) - представлен перегрузками операций и функций%%(сигнатура функции - тип и количество и типы формальных параметров)%%
   2. _Динамический_ (разрешается на уровне выполнения программы) - представлен механизмом виртуальных функций
   3. _Параметрический_ - представлен механизмом шаблонов функций и классов
 + **Наследование** - создание иерархии классов от базовых

---

Следующей особенностью С++ является введение в обиход понятия ***пространства имён***. Пространство имён представляет собой некоторый отдельный набор объектов, объединённый в условно отделённое от остальных объектов множество, с которым мы можем работать. Хорошим примером особенности пространств имён выступает работа макроса препроцессора `#include`. В С все заголовочные файлы и / или библиотеки присоединялись препроцессором в одном файле перед компиляцией программы, составляя из себя единое глобальное пространство имён, отчего иногда случались коллизии этих самых имён, пришедших из разных модулей. В С++ заголовочные и внешние модули всё также присоединяются к глобальному пространству имён, а встроенные библиотеки попадают в отдельное пространство имён `std`, отчего, например, имена объектов в глобальном и `std` пространствах имён могут совпадать и не вызывать ошибок.

```cpp
#include <stdio.h> | #include <cstdio>
                   | 
Содержимое попадает| Попадает в пр-во
В глобальное       | имён std (они тут разделены)
пространство имён  |
```

Существует множество пространств имён, подключаемых вместе с библиотеками (т.е. библиотека описывает какое-то своё пространство имён, и чтобы взаимодействовать с её объектами, над будет делать обращение через это пространство имён), и, кроме того, создавтаь пространства имён можно самостоятельно. Для этого используется ключевое слово `namespace` с указанием имени пространства имён (или без него, если пространство имён должно быть анонимным (в таком случае к нему нельзя будет обратиться извне, однако внутри можно будет описать некий блок кода, который, например, должен единожды сработать при компиляции системы, после чего доступ к нему должен быть невозможен)), после которого в фигурных скобках описываются объекты этого пространства имён:

```cpp
namespace M {
    int i;
    void f() {... i ...}    
}
```

Просто так с объектами из пространства имён, в котором мы не находимся, работать нельзя. Существует два способа взаимодействовать с такими объектами. Первый - ***явное указание принадлежности объекта к пространству имён*** с помощью **операции расширения области видимости** `::` (оно же "четвероточие"). Второй - Подключение всего пространства имён (или отдельных его объектов) к текущему пространству имён с помощью ключевого слова `using`

```cpp
M::i = 10; // :: операция расширения области видимости

using namespace std // подключение всего пространства имён
using M::i;
```

При работе с пространствами имён разрешена вложенность пространств **любого уровня**. Для работы с объектами вложенных пространств имён необходимо будет использовать множество операций расширения области видимости.

```cpp
namespace M {
    int a;
    int f(int x) {a = x;}
    
    namespace B {
        int b;
        void f1(int x, int y) {b = a + x + y;}
    }

	a = 8;
	B::b = 10;
}

M::f(5);
M::B::f1(3, 4);
```

При работе с пространствами имён нужно помнить ***основные правила вложенности и области видимости объектов***:
 + Если во вложенном и внешнем пространствах имён существуют объекты с разными именами, то во вложенном пространстве имён доступны внешние;
 + Если имена объектов одинаковые, то внутренний объект перекрывает внешний, для работы с внешним объектом необходимо явное указание `::` (для объектов из глобального пространства имён указывается четвероточие без имени пространства имён в начале);
 + Область видимости объектов какого-либо пространства имён начинается в месте их определения и продолжается **строго ниже** по коду. До введения `namespace` обращаться к его объектам нельзя даже с явным `::`, после - можно.

Рассмотрим пример, показывающий наглядно области видимости разных пространств имён и обращения к ним:

```cpp
namespace N {
    int f = 2;
    int g = -2;
}

namespace M {
    int f = 3;
    int g = -3;
}

int f = 5;

int main () {
    int f = 1;
    std::cout << ::f << ' ' << N::f << ' ' << M::f << std::endl; // 5 2 3

    using namespace N; // К текущему пространству имён добавили элементы пространства имён N
    std::cout << f << ' ' << g << ' ' << M::f << std::endl; // 1 -2 3
    /*Локальный объект перекрывает глобальный. При отсутствии его была бы ошибка, поскольку на одном уровне глобального пространства имён было бы два имени f: от глобального пространства имён и от пространства имён N*/
}
```

---

В предыдущем примере мы зрительно познакомились с ***особенностями ввода-вывода данных*** в С++. Как и следует ООП языку, он представлен здесь в виде объектов специального вида, хранящихся в библиотеке `iostream`.

```cpp
#include <iostream>
```

`cin` и `cout` - объекты классов `istream` и `ostream` соответственно, для которых специальным образом перенастроены (правильный термин - **перегружены**; перегрузки будут обсуждены нами в будущем) операции битовых сдвигов для организации поточного ввода и вывода данных без использования форматных строк. `cin-cout` автоматически распознают объекты, приводят (если это позволяет компилятор, т.е. у этих объектов существуют методы для преобразования в выводной тип / из выводного типа) их к нужному типу и производят ввод-вывод. 

```cpp
int x = 100;
double y = 3.14;
char str[] = "Строка с пробелами"

std::cout << "x = " << x << " y = " << y << " str = " << str << std::endl;

```

```cpp
int x;
double y;
char str[80];

std::cin >> x >> y >> str; //{100} {3.14} {строка} с пробелами

std::cin.getline(str, 79); // строка с пробелами не более,чем 79
/*у cin и cout есть также другие методы для взаимодействия и обработки данных. Например, getline, принимающий строки с пробельными символами, в отличие от перегруженной базовой операции, читающей до первого пробельного символа*/
```

Объект `endl` используется для организации переноса курсора на новую строку. Использование его предпочтительнее использования символа `\n`, поскольку он также автоматически вызывает очистку буфера ввода-вывода (`fflush`, который использовался для этих целей в С) и дополнительные проверки и спец.действия. Все три объекта принадлежат пространству имён `std`.

Не уходя далеко от ввода-вывода, рассмотрим пару примеров по особой работе с данными:

 + ввод символов

```cpp
char c;

while(std::cin >> c) { //вводим <a b c d> в надежде получить также с пробелами 
    std::cout << c; //напечатается <abcd>, поскольку стоит флаг пропускать минимум один элемент (и все пробельные) при вводе
}

/*            Решение №1            */
std::cin >> std::noskipws; // сбросить флаг

/*            Решение №2            */
while ((c = cin.get()) != EOF) {
    /**/
}
```

 + Манипулирование данными при вводе-выводе 

```cpp
#include <iomanip> /*используется спецальная библиотека*/

// ключевые объекты oct hex dec - действуют на все объекты после указания даных для преобразования данных

std::cout << hex << 17 << " " << 15; // 0x11 0xF

// setw(x) - ширина поля вывода - действует на ближайший объект

std::cout << setw(5) << 10 << 20; // ___1020  - на второе число уже не работает

// setprecision(n) - кол-во знаков после запятой с округлением

std::cout << fixed << showpoint << setprecision(6) << x;

//fixed - ключевой объект, информирующий, что дальше будет вещественное число (без него setprecision будет просто шириной поля)
```

---

Следующее отличие С++ от С - встроенный стандартный тип ***`bool`***, описывающий два объекта - `True` ( != 0 ) и `False` ( == 0 )

---

В С++ появилась возможность добавлять ***указания к исполнению некоторых блоков*** кода. Так, например, ключевое слово `inline` **рекомендует** компилятору не вызывать функцию в отдельном фрейме, как стандартную, а просто подставить в месте вызова её тело в основном фрейме (***Важно:*** это именно рекомендация, а не обязательное действие, функция может и не подставиться, а отработать, как обычная)

```cpp
inline int sum(int x, int y) {
    int z;
    z = x + y;
    return z;
}
```

---

Имена ***структур*** в С++ теперь не содержат ключевого слова `struct` (справедливости ради, они теперь и структурами в привычном понимании С не являются, этот вопрос будет обсуждён в будущем)

---

В С++ появился отдельный ***механизм преобразования типов***. 

```cpp
int i = 123;
double x;

x = (double) i; // Вариант из С, просто перенос данных из одной упаковки в другую без защиты, контроля данных и т.д.; крайне не рекомендуется

x = double(i); // Использование объекта, описывающего тип данных, для которого перегружена операция () 

x = static_cast<double>(i); // Специальный объект для преобразования типов со встроенными проверками допустимости операции; крайне желателен
```

---

В С++ для функций были добавлены ***значения аргументов по умолчанию***.

```cpp
void f(int a, int b = 10, int c = 30);

f(1);
f(1, 2);
f(1, 2, 3);
```

 + Значения по умолчанию определяются **единожды**: либо при объявлении функции, либо при её определени;
 + Все значения по умолчанию пишутся в конце, невозможно задать аргумент со значением по умолчанию до аргумента без значения по умолчанию.

---

Для контроля динамической памяти в С++ добавлены ***специальные парные операторы*** `new - delete` и `new [] - delete []` для описания одинарных динамических объектов и динамических массивов соответственно. Отличительное свойство их от классических операторов аллокации памяти - встроенный автоматический запуск конструкторов и деструкторов объектов (что такое конструкторы и деструкторы, мы обсудим в будущем; сейчас скажем, что это функции, сопровождающие создание и уничтожение объектов)

```cpp
int* p = new int;
delete p;

A* p = new A; // вызов конструктора по умолчанию

int* p = new int(99);
A* p = new A(99); // конструктор преобразования

int* p = new int[100]
delete [] p;
```

При ошибке работы с памятью генерируется исключение `bad_alloc` (исключение - ещё одна отличительная особенность С++, о ней мы поговорим ближе к концу изучения С++ в этом курсе)

Поскольку необработанное исключение (а его обработку мы посмотрим ближе к концу) будем аварийно завершать программу, для проверки корректности операций необходимо использовать ключевое слово `nothrow`

```cpp
p = (nothrow) new int [1000]

if (p == NULL) {
    /**/
}
```

---

В С++ появился новый тип данных - ***ссылка***. Он представляет собой объект, описывающий ту же область памяти, что уже существует под каким-то именем (т.е. представляет собой **второе имя** для уже существующего объекта), однако может быть создан в другом фрейме и использоваться там.

```cpp
int x = 5;
int& y = x;

 x, y
|   5|
```

Классический пример использования ссылочных переменных - при работе с изменяющимися внутри функции внешними данными. Если раньше для этого использовались указатели, сильно загромождавшие код и ухудшающие его понимание, теперь появилась возможность выполнять те же действия с упрощением синтаксиса.


```cpp
/* Pointer Usage */
void f(int* x) {
    *x += 100;
}

int main() {
    int a = 2;
    f(&a);
}
```


```cpp
/* Reference Usage */
void f(int& x) {
    x += 100;
}

int main() {
    int a = 2;
    f(a);
}
```






























