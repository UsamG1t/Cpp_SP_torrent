`RTTI` - важный механизм динамического определения и преобразования типов, позволяющий в процессе работы программы определять реальные типы передаваемых с помощью ссылок и указателей объектов и при необходимости преобразовывывать их.

`RTTI` - один из двух механизмов, способных в процессе работы программы определять **реально передаваемый** тип объекта. второй такой механизм - механизм виртуализации. Ни один другой (по крайней мере, изучаемый в курсе) механизм не может выделить реально передаваемый объект, указатель или ссылку на который программа получила.

`RTTI` для практического использования предоставляет две функции. Первая - `typeid` - позволяет определять тип объекта-аргумента. На вход функции подаётся по указателю или ссылке сам объект, а на выходе получается ссылка на объект класса `type_info` - специальный информационный обьект, для которого определён метод `name()`, возвращающий имя класса (то, как его видит компилятор), и который можно сравнивать  на равенство (`==` / `!=`). При получении невалидного указателя (`null_ptr`) `typeid` выбрасывает исключение `bad_typeid`.

```cpp
class A { // полиморфный класс; все его наследники полиморфные
public:
    virtual void f(){}
};

class B: public A{};

int main() {
    A a, *pa;
    B b, *pb;

    pa = new B;
    cout << typeid(*pa).name(); // на вход - объект, на выход - ссылка на type_info(их можно сравнивать == !=)
                                // 1B

    /*безопасное приведение*/
    if (typeid(*pa) == typeid(B)) {
        pb = (B*) pa; // понижающее приведение: от базового к производному
    }
}
```

Почему так важно проводить определение типа передаваемого объекта? Довольно часто мы не можем заранее сказать, какого типа объект получим для работы. При этом работа со множеством производных классов через указатели и ссылки на базовый класс позволяет унифицировать обращение к объектам и отдельно реализовывать лишь различные обработки. \
Также важно поддерживать корректность данных, для чего также необходимо определение типов. При **повышающем приведении типов** (от объекта производного класса к объекту базового) никакой проблемы не возникает (на этом и основана логика управления через базовые указатели и ссылки): для базового объекта просто не видна та часть производного класса, по которой с базовым проходит отличие. В случае же **понижающего приведения** область видимости объекта, наоборот, увеличивается, и в случае несоответствия типов возможно нарушение целостности памяти (начнём работать с чужими данными).

Объединяет действие проверки и приведения типов шаблонная функция `dynamic_cast`. Она проводит проверку типов **реального** исходного и **требуемого** итогового объектов и при разрешении проводит приведение. \
В случае небезопасного приведения `dynamic_cast` по-разному реагирует на указатели и ссылки: в случае указателей в результат будет возвращён `null_ptr`, в случае ссылки - будет выброшено исключение `bad_cast`.

```cpp
class A {
public:
    virtual void f(){}
};

class B: public A{};

int main() {
    A a, *pa;
    B b, *pb;

    pa = &b;
    if (pb = dynamic_cast<B*>(pa)) { 
    } else {
	    std::cout << "Oh no!" << std::endl;
    }

    A& ra = b;
    try {
	    B& rb = dynamic_cast<B&>(ra);
    }
    catch(bad_cast){}

}
```