Механизм виртуализации - алгоритм динамического полиморфизма, представляющий из себя возможность использования производных объектов через управление базовыми объектами.

# Виртуальное наследование

Немного отдельным блоком в теме виртуализации висит виртуальное наследование.

Допустим, есть некоторая иерархия классов, по разным веткам зависимая от одного базового класса:

```
P -> B1
P -> B2
B1 B2 -> D
```

```cpp
class P{
public:
    int p;
};

class B1: public P{};
class B2: public P{};

class D: public B1, public B2 {};
```

При создании объекта какого-то класса в области памяти можно выделить часть объекта, описывающую базовый класс, и часть, описывающую отличные от базового элементы производного класса. 

В случае создания объекта класса `D` по вышеописанной иерархии объект будет иметь условно такую структуру:

```
|-----------|
|     P     |
|           |
|-----------|  B1
|    B1\P   |
|           |
|-----------|
|     P     |        D
|           |
|-----------|  B2
|    B2\P   |
|           |
|-----------|
| D\(B1|B2) |
|           |
|-----------|
```

В таком случае при обработке членов класса `P`  в объекте класса `D` у компилятора возникает проблема: существует две области с идентичным наполнением, необходимо указать явное обращение к какой-то из них, что невозможно
```cpp
D obj;
obj.p; // ошибка
```

В таком случае при наследовании используется ключевое слово `virtual`. В таком случае в объекте будет единственное физическое использование базового класа, а в содержащих его производных классах будет ссылка на него

```cpp
class P{
public:
    int p;
};

class B1: virtual public P{};
class B2: virtual public P{};

class D: public B1, public B2 {};

// P один, а в В1 и В2 на него ссылки
```

# Виртуальные функции

Пройдён по всем требованиям, необходимым для работы механизма виртуализации:

 + Для начала необходима **иерархия классов**:
```cpp
class A {
//...
};

class B: public A {
//...
};
```

 + В базовом классе описана некоторая функция с ключевым словом `virtual`
 + В производном классе описана функция с _тем же_ **именем**, _той же_ **сигнатурой** (количество, порядок и типы аргументов), а также _тем же_ **типом возвращаемого значения** (**единственное** исключение - возврат ссылки/указателя с базового класса можно поменять на производный)

```cpp
class A {
public:
	virtual void f(int x) {std::cout << 1;}
};

class B: public A {
	void f(int y) {std::cout << 2;}
};
```

 + При работе с **производным** классом используется указатель или ссылка на **базовый** класс

```cpp
class A {
public:
	virtual void f(int x) {std::cout << 1;}
};

class B: public A {
	void f(int y) {std::cout << 2;}
};

int main() {
	A a;
	B b;
	A* pa = &b;
	A& ra = b;

	a.f(); // 1
	b.f(); // 2
	pa->f(); // 2
	ra.f(); // 2
}
```

В таком случае при обращении к виртуальной функции из указателя/ссылки базового класса будет происходить "провал" в производный класс и реализация его функции. **Важно:** проверка коректности соответствия функции проводится в базовом классе, лишь после этого проверяется допустимость к реализации её виртуализации.  

**Ещё два важных замечания:**
1. Важно соблюдать политику относительно работы с конструкторами и деструктором: конструкторы ***не могут*** быть виртуальными, деструктор ***должен*** быть виртуальным

```cpp
class A{ public: A() {std::cout << 1;}
                ~A() {std::cout << 11;}
};

class B: public A { public: B() {std::cout << 2;}
                            ~B() {std::cout << 22;}
};

int main() {
    A* pa;
    A* pp;
    B* pb;

    pa = new A; // 1
    pb = new B; // 12

    pp = pa; delete pp; // 11
    pp = pb; delete pp; // 11 | и память потеряли
}
```

```cpp
class A{ public: A() {std::cout << 1;}
                virtual ~A() {std::cout << 11;}
};

class B: public A { public: B() {std::cout << 2;}
                            ~B() {std::cout << 22;}
};

int main() {
    A* pa;
    A* pp;
    B* pb;

    pa = new A; // 1
    pb = new B; // 12

    pp = pa; delete pp; // 11
    pp = pb; delete pp; // 2211
}
```

2. Вообще говоря, функция в базовом классе может быть неопределена вовсе. В таком случае говорят о **чистой виртуальной функции**:
```cpp
virtual void f() = 0; // чистая виртуальная функция
```

Класс, содержащий чистые виртуальные функции, называется **абстрактным**. До момента подмены (явного определения) этой функции все наследники данного класса также являются абстрактными. \
Для абстрактных классов можно создавать указатели и ссылки, но нельзя создавать объекты.


Рассмотрим на примере, как механизм виртуальных функций реализовывает себя на практике:

```cpp
class X {
public:
    virtual int g (double x) {
        h ();
        cout << "X::g" << endl;
        return 1;
    }

    void h () { t (); cout << "X::h" << endl;}
    virtual void t () { cout << "X::t" << endl;}
};

class Z: public X {
public:
    int g (double y) {
        h ();
        cout << "Z::g" << endl;
        return 3;
    }

    virtual void h () { t (1); cout << "Z::h" << endl; }
    virtual void t (int k) { cout << "Z::t" << endl; }
};

int main(){
    X a; Z b; X * p = &b; 
    p -> g(1.5); // (1)
    p -> h(); // (2)
    p -> t(5); // (3)
}
```

(1): Через указатель базового класса вызываем функцию `g(1.5)`. Обращение корректное (функция в классе существует, сигнатура $int\ g(double)$). Функция имеет ключевое слово `virtual` - проверяем остальные условия для виртуализации: иерархия классов  - **есть**, под указателем базового класса объект производного - **есть**, в производном классе есть функция $int\ g(double)$ - **есть**. Соответственно, применим механизм виртуализации, мы проваливаемся в реализацию функции в классе `Z`. \
После провала выше подняться функции уже не могут, дорабатывают на текущем уровне или ниже. Соответственно, вызываемые в `g` функция `h` и в `h` функция `t` также принадлежат классу `Z`. Вывод: `Z::t Z::h Z::g`

(2): Через указатель базового класса вызываем функцию `h()`. Обращение корректно (функция в классе существует, сигнатура $void\ h()$). Однако ключевое слово `virtual` отсутствует (его наличие в призводном классе не играет роли, слово должно быть при функции в базвом классе), следовательно обработка берётся из класса `X`. \
В классе `X` в функции `h` вызывается функция `t`. Обращение корректное (функция в классе существует, сигнатура $void\ t()$). Функция имеет ключевое слово `virtual` - проверяем остальные условия для виртуализации: иерархия классов  - **есть**, под указателем базового класса объект проиводного - **есть**, в производном классе есть функция $void\ t()$ - **нет**. Следовательно, механизм виртуализации неприменим, вывод: `X::t X::h`

(3): Через указатель базового класса вызываем функцию `t(5)`. Обращение **некорректно** (такой функции в базовом классе не существует), ошибка обработки.