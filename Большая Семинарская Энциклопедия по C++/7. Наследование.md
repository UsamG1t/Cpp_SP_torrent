Наследование - одна из трёх ключевых составляющих ООП, позволяющая создавать классы на основе уже существующих. При этом новый класс называется _производным_, исходный класс - _базовым_. Производный класс наследует поля и методы базового класса, но также может добавлять свои члены класса и / или перегружать уже существующие (унаследованные от базового класса).

Наследование по уровням доступа к данным делится на `private`, `protected` и `public` наследование соответственно. тип наследования влияет на доступность членов базового класса в производном и его потомках:
 + `public`-наследование сохраняет доступ к объектам базового класса **в неизменном виде**: для данного производного класса `public` члены базового класса останутся `public` (доступны всем), `protected` члены базового класса останутся `protected` (доступны прямым потомкам базового класса, но недоступны вне класса), `private` члены базового класса останутся `private` (недоступны нигде, кроме самого базового класса);
 + `protected`-наследование делает `public` и `protected` члены базового класса `protected`, `private` оставляет `private`;
 + `private`-наследование (именно оно идёт по умолчанию) все члены базового класса передаёт в производный, как `private`.

 При этом если внутри методов производного класса использовать методы базового класса, внутри них `private`-члены базового класса, логично, будут доступны (поскольку для членов базового класса они доступны по определению).

***Не наследуются***:
 + Конструкторы
 + Деструктор
 + Перегруженный оператор присваивания

```cpp
class A
{
    int priv;
protected:
    int a;
public:
    A(int x = 0): a(x), priv(1) {}

    int f() {std::cout << a << priv << '/'; return priv;} // Оперирует только собственными полями
};

class B: public A {                        // class ClassName: {prop}BaseClass
protected:
    int b;
public:
    B(int x = 1, int y = 2): A(x), b(y) {}
    void f() {std::cout << A::f() + b << '/';} // Обращается к методу базового класса, где доступны даже приватные поля базового класса 
};

class C: public B {                        // class ClassName: {prop}BaseClass
    int c;
public:
    C(int x = 1, int y = 2, int z = 3): B(x, y), c(z) {}
    void f() {std::cout << a + b + c << std::endl;} // обращается к protected-полям базовых классов напрямую, имеет к ним доступ
};


int main () { 
    A o1; 
    B o2;
    C o3;

    o1.f(); // 01/
    o2.f(); // 11/3/
    o3.f(); // 6

    return 0;
}
```

Не просто так в списке инициализации производных классов указаны конструкторы базовых классов. Перед работой конструкторов производных классов должны отработать конструкторы базовых классов, от которых производный унаследован. Если к конструкторе производного класса не указан явно конструктор базового, автоматически неявно туда подставляется конструктор по умолчанию:
```cpp
B(int x = 0, int y = 0): b(y) {}
/* Upgrade to */
B(int x = 0, int y = 0): A(), b(y) {}
```
При отсутствии такого конструктора компилятор выдаст ошибку.

В случае срабатывания конструктора копирования (КК) производного работает аналогичная схема: при указании КК базового используется он, при его отсутствии подставляется КК умолчания. Если у производного класса отсутствует КК, будет создан новый объект, в котором будет использован КК базового.

При удалении объекта производного класса происходит сначала срабатывание деструктора производного класса, после - базового (в обратном конструкторам порядке).

Не стоит путать производные классы и классы, содержашие в качестве полей объекты других классов. Для производных классов создание конструкторов фиксировано: отбазового до производных. Для классов с полями-объектами порядок вызова конструкторов определяется порядком полей в классе, а не порядком в списке инициализации.

```cpp
class A{
//
};

class B: public A {
//
};

int main() {
	B a; // [A() B()]
	class C {
		B b;
		A a;
	public:
		C(): a(), b() {}
	} c; // [A() B()] [A()] C()

	return 0; // ~C() ~A() [~B() ~A()] [~B() ~A()]
}
```


При наследовании от множества базовых классов инициализация и удаление объектов сопровождается конструкторами-деструкторами всех базовых классов

```cpp
class B1 {
    int a;
public:
    B1(){}
};

class B2 {
    int aa;
public:
    B2(){};
};

class D: public B1, public B2 {
    int aaa;
public:
    D(){}; // B1() B2() D()
};
```

