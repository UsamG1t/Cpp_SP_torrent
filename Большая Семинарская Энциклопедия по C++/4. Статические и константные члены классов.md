Первая встреча со статическими и константными элементами кода произошла ещё в Си. Здесь расширяется использование ключевых слов `static` и `const` для использования из в классах.

### Ключевое слово `static`

Cтатические члены представляют из себя глобальные объекты, область видимости которых ограничена модулем их определения. В случае класса модулем определения является сам класс.

Статические переменные класса определяются одни на все объекты класса, доступ к ним возможен даже при отсутствии объекта, для этого необходимо явно указывать область видимости (через `::`).

Так как статические переменные не связаны с экземплярами объектов, необходимо отдельно создавать их в глобальном пространстве имён с указанием области видимости.

```cpp
struct S {
    char a;
    double x;
    static int n; // определяется одна на все объекты
};

int s::n; // без этого не будет работать

int main() {
	S obj1, obj2;
	obj1.n = 80;
	std::cout << obj2.n << s::n; // 80 80
}
```

При использовании статических методов перед описанием также пишется ключевое слово `static`. Статические методы также могут быть вызваны без привязки к объектам с помощью указания области видимости.

```cpp
class A {
    static int a;
public:
    A(int x): a(x){}

    static void ini(int x) { // Со статическими полями могут работать ТОЛЬКО статические функции
        a = x;
    }

    static void print(void) {
    std::cout << a << std::endl;
    }
}

int A::a = 77; 

int main() {
    A::ini(8); // статические функции можно вызывать даже без существования объекта класса
    A::print();
    A obj(10); // значение а будет заменено на 10, новая не создаётся
    obj.print();
}
```

Основные правила работы со статическими методами:
 + `Static` метод работает **только** со `static` полями;
 + Статический метод может вызывать **только** статические методы;
 + `Static` метод не может быть объявлен как _константный_ или _виртуальный_ (механизм виртуализации будет рассмотрен в будущем)


### Ключевое слово `const`

Кроме константных **объектов** также выделяются отдельно константные **поля** и константные **методы** классов. Для описания константных элементов используется ключевое слово `const`, приписываемое **справа** от элемента (про область действия ключевого слова `const` - в `Дополнительных знаниях`).

Константные объекты и поля не могут быть изменены после инициализации. \
Константные методы в процессе работы не меняют объект, для которого они вызваны (даже если объект изменяемый)

```cpp
class A {
public:
	int f(int n) const {
		std::cout << "Const function" << std::endl;
	}
};
```

Если с константными полями проблем не возникает, логика работы для них никак не меняется (напомним, что они **должны быть определены** при инициализации), то в учётом возможности использования статических элементов выделяются особые правила работы для константных объектов и методов:

 + Константный метод не может изменять вызвавший её объект кроме `static` и `mutable` полей;
 + Константный метод может вызывать **только** константные и статические методы;
 + Константные объекты могут вызывать **только** константные и статические методы;
 + Константный объект должен быть проинициализирован при объявлении;
 + В константных объектах можно менять только `static` и `mutable` поля

```cpp
struct A {
    static int i;
    
    void f() const { // вызывается из константного метода -> должен быть константным
        cout << "f()" << endl;
    }

    void g(int n) const{ // вызывается из константного объекта -> должен быть константным
        i = n; // работа только со статическими полями
        f();
        cout << "g ()" << endl;
    }
};

int A::i = 1; // инициализация статических полей

int main () {
    const A a;
    a.g(2);
    return 0;
}

```