# 1. Ключевое слово `const` и его действие

Ключевое слово `const`, описывающее константность объектов кода, в С++ используется не только в качестве маркера константности элементов (например, переменных), но и для описания константности функций. 

Об этом действии ключевого слова будет описано в одной из глав энциклопедии, здесь же мы рассмотрим унифицированную для всех элементов область действия ключевого слова. Действие `const` распространяется на ***ближайший слева*** элемент, к которому он применим. Если `const` описано самым левым словом, его применение распространяется на самый левый "применяющий константность" элемент. К ссылкам `const` **не** применим, поскольку ссылка по своей природе не является изменяемым объектом (а вот тип ссылки поддерживает константность; поэтому могут быть ссылки на переменные обычных типов или на переменные константных типов)


```cpp
const A a; // константный тип А
A const b; // константный тип А
A const * c; // изменяемый указатель на константный тип А
A* const d; // константный указатель на изменяемый тип А
```

# 2. Некоторые особенности С++11

В курсе СП изучается, вообще говоря, стандарт С++98. Однако задания практикума пишутся и решаются стандартами более высокого уровня. Вот несколько полезных вещей, добавленных в стандарт С++11:

 + Объект `nullptr` - нулевой указатель, не приводящийся к целочисленным типам, поскольку базируется на указательной структуре, а не на числовой (как `NULL`):
```cpp
f(char*);
f(int);

int main() {
    f(NULL); // f(int)
    f(nullptr); // f(char*)
}
```

 + rvalue-ссылка - (достаточно грубое упрощение в рамках курса: на деле это более тонкий по структуре и свойствам объект) позволяет сохранять и работать с rvalue-значениями; примером таких значений могут выступать, например, возвращаемые по значению (а не по обычной ссылке) значения функций.
```cpp
X a;
X f();
X& r1 = a;
X&& rr1 = f();
```

   На основе rvalue-ссылок можно создавать **конструкторы переноса**:
```cpp
String(String&& v) { // конструктор переноса
    str = v.str;
    len = v.len;
    v.str = nullptr; //!
} 

String f() {
    String a, b;
    
    /**/

    return a + b; // тк есть конструктор переноса, компилятор просто передаст указатель на динамическую память временного объекта, а не создаст новую - скопирует - удалит старую
}
```


# 3. Предикаты

Предикаты - это специальные классы с перегруженным оператором `()`, с помощью которого можно реализовывать проверки, фильтрацию или встраивать дополнительные алгоритмы обработки объектов

```cpp
struct Pred() {
    bool operator()(int v) {
        return v < 10;
    }
};

void f(int* mas, int n, Pred c) {
    for (int i = 0; i < n; i++) {
        if(c(mas[i])) {
            mas[i] *= 2;
        }
    }
}
```


# 4. Функция `::swap`

Функция `::swap` производит обмен значениями двух элементов-аргументов, делая это через внутренные буферы без создания отдельных временных объектов. На основе данной функции возможно реализовывать оптимальные операции, включающие в себя обмен.

***TODO:*** объяснить, как работает данный оператор присваивания в случае работы **со временными объектами** и почему данный способ оптимальнее ранее описанных (**именно для временных объектов**):
```cpp
void String::swap(String & a) {
    ::swap(str, a.str);
    ::swap(len, a.len);
}

String& String::operator=(String a) {
    swap(a);
    return *this;
}
```


# 5. Операторы аллокации памяти и конструктор с размещением

При работе с динамической памятью при использовании операции выделения памяти `new` для объектов автоматически вызывается конструктор. Однако в некоторых случаях требуется лишь выделение необходимого объёма памяти без лишнего создания объектов (например, при создании динамического и **изначально пустого** массива, который по ходу программы будет динамически изменяться, перезаполняться и т.д.). 

В таком случае правильнее использовать **операторы выделения-удаления памяти**:
```cpp
void* operator new(size_t size)
void operator delete(void* p)
```

При их использовании только выделяется-удаляется память, не осуществляя никаких действий с объектами. Для заполнения памяти необходимо явно вызывать **конструктор объекта с размещением** с помощью конструкции `new(<memory_address>)`,  а после работы с объектом - принудительно вызывать деструктор.

```cpp
struct MyCl {
    MyCl(){};
    ~MyCl(){};
};

MyCl* p = new MyCl; // Сразу создание объекта в динамической памяти
depete p; // Сразу удаление объекта и освобождение памяти

MyCl* pp = static_cast<MyCl*>(::operator new(sizeof(MyCl))); // выделение ТОЛЬКО памяти
MyCl* ptr = new(pp) MyCl; // принудительный вызов конструктора с размещением
ptr->~MyCl(); // принудительный вызов деструктора
::operator delete(pp); // освобождение памяти
```

Пример использования операторов выделения-удаления памяти для реализации стека:

```cpp
class Stack {
    C* ptr;
    int used;
    int alloc;

public:
    
    Stack(int u = 0; int a = 8): used(0), alloc(a) {
        ptr = static_cast<C*>(::operator new(sizeof(C)));
    }

    Stack(const Stack & v): used(v.used), alloc(v.alloc) {
        ptr = static_cast<C*>(::operator new(sizeof(C)));

        for (int i = 0; i < used; i++) {
            new(ptr + i /*&ptr[i]*/)C(v.ptr[i]);
        }
    }

    ~Stack() {
        for (int i = 0; i < used; i++) {
            (ptr + i)->~C();
        }

        ::operator delete(ptr);
    }
};
```


