# 1. Ключевое слово `const` и его действие

Ключевое слово `const`, описывающее константность объектов кода, в С++ используется не только в качестве маркера константности элементов (например, переменных), но и для описания константности функций. 

Об этом действии ключевого слова будет описано в одной из глав энциклопедии, здесь же мы рассмотрим унифицированную для всех элементов область действия ключевого слова. Действие `const` распространяется на ***ближайший слева*** элемент, к которому он применим. Если `const` описано самым левым словом, его применение распространяется на самый левый "применяющий константность" элемент. К ссылкам `const` **не** применим, поскольку ссылка по своей природе не является изменяемым объектом (а вот тип ссылки поддерживает константность; поэтому могут быть ссылки на переменные обычных типов или на переменные константных типов)


```cpp
const A a; // константный тип А
A const b; // константный тип А
A const * c; // изменяемый указатель на константный тип А
A* const d; // константный указатель на изменяемый тип А
```

# 2. Некоторые особенности С++11

В курсе СП изучается, вообще говоря, стандарт С++98. Однако задания практикума пишутся и решаются стандартами более высокого уровня. Вот несколько полезных вещей, добавленных в стандарт С++11:

 + Объект `nullptr` - нулевой указатель, не приводящийся к целочисленным типам, поскольку базируется на указательной структуре, а не на числовой (как `NULL`):
```cpp
f(char*);
f(int);

int main() {
    f(NULL); // f(int)
    f(nullptr); // f(char*)
}
```

 + rvalue-ссылка - (достаточно грубое упрощение в рамках курса: на деле это более тонкий по структуре и свойствам объект) позволяет сохранять и работать с rvalue-значениями; примером таких значений могут выступать, например, возвращаемые по значению (а не по обычной ссылке) значения функций.
```cpp
X a;
X f();
X& r1 = a;
X&& rr1 = f();
```

   На основе rvalue-ссылок можно создавать **конструкторы переноса**:
```cpp
String(String&& v) { // конструктор переноса
    str = v.str;
    len = v.len;
    v.str = nullptr; //!
} 

String f() {
    String a, b;
    
    /**/

    return a + b; // тк есть конструктор переноса, компилятор просто передаст указатель на динамическую память временного объекта, а не создаст новую - скопирует - удалит старую
}
```


# 3. Предикаты

Предикаты - это специальные классы с перегруженным оператором `()`, с помощью которого можно реализовывать проверки, фильтрацию или встраивать дополнительные алгоритмы обработки объектов

```cpp
struct Pred() {
    bool operator()(int v) {
        return v < 10;
    }
};

void f(int* mas, int n, Pred c) {
    for (int i = 0; i < n; i++) {
        if(c(mas[i])) {
            mas[i] *= 2;
        }
    }
}
```


# 4. Функция `::swap`

Функция `::swap` производит обмен значениями двух элементов-аргументов, делая это через внутренные буферы без создания отдельных временных объектов. На основе данной функции возможно реализовывать оптимальные операции, включающие в себя обмен.

***TODO:*** объяснить, как работает данный оператор присваивания в случае работы **со временными объектами** и почему данный способ оптимальнее ранее описанных (**именно для временных объектов**):
```cpp
void String::swap(String & a) {
    ::swap(str, a.str);
    ::swap(len, a.len);
}

String& String::operator=(String a) {
    swap(a);
    return *this;
}
```


# 5. Операторы аллокации памяти и конструктор с размещением

При работе с динамической памятью при использовании операции выделения памяти `new` для объектов автоматически вызывается конструктор. Однако в некоторых случаях требуется лишь выделение необходимого объёма памяти без лишнего создания объектов (например, при создании динамического и **изначально пустого** массива, который по ходу программы будет динамически изменяться, перезаполняться и т.д.). 

В таком случае правильнее использовать **операторы выделения-удаления памяти**:
```cpp
void* operator new(size_t size)
void operator delete(void* p)
```

При их использовании только выделяется-удаляется память, не осуществляя никаких действий с объектами. Для заполнения памяти необходимо явно вызывать **конструктор объекта с размещением** с помощью конструкции `new(<memory_address>)`,  а после работы с объектом - принудительно вызывать деструктор.

```cpp
struct MyCl {
    MyCl(){};
    ~MyCl(){};
};

MyCl* p = new MyCl; // Сразу создание объекта в динамической памяти
depete p; // Сразу удаление объекта и освобождение памяти

MyCl* pp = static_cast<MyCl*>(::operator new(sizeof(MyCl))); // выделение ТОЛЬКО памяти
MyCl* ptr = new(pp) MyCl; // принудительный вызов конструктора с размещением
ptr->~MyCl(); // принудительный вызов деструктора
::operator delete(pp); // освобождение памяти
```

Пример использования операторов выделения-удаления памяти для реализации стека:

```cpp
class Stack {
    C* ptr;
    int used;
    int alloc;

public:
    
    Stack(int u = 0; int a = 8): used(0), alloc(a) {
        ptr = static_cast<C*>(::operator new(sizeof(C)));
    }

    Stack(const Stack & v): used(v.used), alloc(v.alloc) {
        ptr = static_cast<C*>(::operator new(sizeof(C)));

        for (int i = 0; i < used; i++) {
            new(ptr + i /*&ptr[i]*/)C(v.ptr[i]);
        }
    }

    ~Stack() {
        for (int i = 0; i < used; i++) {
            (ptr + i)->~C();
        }

        ::operator delete(ptr);
    }
};
```


# 6. Упрощение работы с итераторами

## Функции арифметических операций над `bidirectional` итераторами

Для `bidirectional` итераторов недоступны арифметические операции, позволяющие перемещать итераторы на произвольное расстояние. для решения этой проблемы можно использовать специальные шаблонные функции, применяющие пошаговое перемещение самостоятельно на указанное количество шагов:

```cpp
advance(p, n); // перемещает итератор p на n элементов контейнера соответственно логике перемещения итератора (прямой или обратный итератор, соответственно)
distance(p1, p2); // возвращает расстояние между двумя итераторами
```

## Разворот итераторов

Вроде бы, из обратного итератора можно конструктором сделать обычный итератор (`Проверьте!`), но для этого есть специальные функции. Особенно это полезно для однозначно корректной работы методов, например, для `erase`:

```cpp
iterator p
reverse_iterator rp

p = rp.base() // выдаст Следующий по-человечески элемент
--p;
erase(p);
```

# 7. Лямбда-функции

Лямбда-функция - это анонимный объект функции, определяемый и используемый прямо в месте определения. Обычно лямбда-выражения используются для инкапсулирования нескольких строк кода, передаваемых алгоритмам или асинхронным функциям.

Структура лямбда-функции:
![](Attached_materials/lambda_function_structure.png)

1. **`Capture`-область** - здесь указываются переменные, которые подтягиваются в лямбда-функцию из внешнего пространства имён:
	1. `[]` - Без доступа к внешней области
	2. `[i, &j]` - явное указание доступа к конкретным объектам внешней области _по значению_ и _по ссылке_ соответственно
	3. `[=]` - Доступ ко всем внешним объектам по значению (считаются **неизменяемыми**$^*$)
	4. `[&]`- Доступ ко всем внешним объектам по ссылке
2. **Список аргументов** лямбда-функции
3. (необязательно) **Спецификация изменяемости по значению** - чтобы объекты, переданные из внешней области по значению, были изменяемыми, необходимо указывать ключевое слово `mutable`
4. (необязательно) **Спецификация обработки исключений** - можно явно указать типы допустимых исключений, генерируемых при ошибке, можно указать запрет выброса исключений (ключевое слово `nothrow`), можно оставить обработку исключений компилятору (ничего не указывать)
5. (необязательно) **Возвращаемое значение лямбда-функции**
6. **Тело лямбда-функции**

```cpp
int x = 5;
auto lf1 = [](int a) {std::cout << a}; // пустые [] - функция ничего не захватывает
auto lf2 = [&x]() {std::cout << x;}; // захват внешних элементов (можно по ссылке)

lf1(x); // 5
lf2(); // 5
```

Пример явного использования в функции:

```cpp
ForwardIt remove_if(ForwardIt first, ForwardIt last, Unary Predicate) {
    std::vector<int> v{2, 4, 5, 6, 7, 8, 9};
    auto end = remove_if(v.begin(), v.end(), [](int x) {return x%2 == 0;});
    // {5, 7, 9, {сюда, на первый чётный элемент, вернётся auto end}/*любой порядок чётных*/}
}
```

