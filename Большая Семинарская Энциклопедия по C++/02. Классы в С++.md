Вместе с приходом в язык парадигмы ООП появилась возможность создания собственных объектов - ***классов***. Класс описывает некий объект, его поля и методы, задаёт механизмы взаимодействия / иерархии и т.д.

Для описания класса используются ключевые слова `class` и `struct`. Да, в С++ пропадает привычное понимание структуры, как объединения под общим именем нескольких данных. теперь этим ключевым словом также описывается объект. 

Разница между `class` и `struct` заключается в уровне доступа к данным класса. В С++ существует три типа доступа к данным: `private`, `protected`, `public`. `private`-данные доступны только для самого объекта и могут использоваться только в его методах. `protected`-данные доступны для самого объекта и его прямых наследников (к этому уровню доступа мы вернёмся только в главах с наследованием, пока просто знаем, что оно существует). `public`-данные доступны всем объектами могут быть использованы в любом месте, где определены и существуют. В классах, объявленных через `class`, для всех объектов (если не сказано иное) установлен `private`-доступ, для объявленных через `struct` - `public`-доступ.

```cpp
class A {
	// По умолчанию private
public:
	// С этого места всё public
};

struct B {
	// По умолчанию public
private:
	// С этого места всё private
};
```

```cpp
class A {
    int a;
public:
    
    void set_a(int x) {
        a = x;
    }

    int get_a() {
        return a;
    }
};

int main() {
    A obj; // класс А, экземпляр класса (объект класса) obj
    obj.set_a(17);
    std::cout << obj.get_a() << std::endl;
}
```


# Конструкторы и деструкторы

Для описания объектов необходимо, как минимум, описать два основных метода (вернее, два "набора" методов) - ***Конструктор*** и ***Деструктор***. Первый описывает действия, сопутствующие созданию объекта, второй - уничтожению объекта. Если быть более точным, на момент выполнения конструктора **уже существует память**, выделенная под него, **определены поля и методы** класса объекта, объект как бы существует для самого себя (и выполнения своего конструктора, соответственно), но ещё не существует для всей программы. При выполнении деструктора объект выполняет указанный алгоритм, после чего уничтожается.

Вообще говоря, конструкторы-деструкторы есть не только у описываемых нами вручную классов, а вообще у всех объектов. Для встроенных типов нам всего лишь недоступен исходный код их реализации (соответственно, посмотреть или изменить их конструкторы-деструкторы мы не можем).

Для описания объектов **в обязательном порядке** регламентируются ***два вида конструкторов, оператор присваивания и деструктор.*** Отсутствие явного определения или указания относительно любого из них компилятором воспринимается, как указание создания **метода по умолчанию**. Имена конструкторов и деструктора совпадают с названием класса объекта.

Первый вид конструктора - **конструктор преобразования**. Он срабатывает в момент инициализации объекта параметрами (или без них). Конструктор может иметь параметры или не иметь их, сами параметры могут иметь значения по умолчанию.  При отсутствии хотя бы какого-то конструктора преобразования (с параметрами или без), **по умолчанию** автоматически создастся **пустой конструктор**.

```cpp
class A {
    int a;
public:
    A(int x = 0): a(x) {} // можно делать значения по умолчанию
    
    int get_a() {
        return a;
    }
};

int main() {
    A obj(17); // конструктор преобразования
    A obj2; // Конструктор со значением по умолчанию
    std::cout << obj.get_a() << ' ' << obj2.get_a()<< std::endl; // 17 0
}
```

В конструкции кода, описывающего любой конструктор, существует специальная область, ограниченная закрывающейся скобкой аргументов и открывающейся скобкой тела конструктора - ***область инициализации***. В ней описываются связанные с работой данного конструктора действия конструкторов иерархически более низкого уровня, выполняющиеся непосредственно перед выполнением тела конструктора (например, конструкторы полей объекта; в коде выше как раз такой случай, поле `a` вызывает свой конструктор от аргумента `x` (ещё одно доказательство, что, вообще говоря, всё в С++ - объекты) )

При описании конструктора с одним параметром компилятор позволяет использовать _неявный_ конструктор преобразования. Избежать этого позволит явное указание запрета неявных преобразований с помощью ключевого слова `explicit`

```cpp
struct A {
    A(int x) { std::cout << "Cons" << std::endl; }
};

struct B {
    explicit B(int x) { std::cout << "Explicit Cons" << std::endl; }
};

int main() {
A obj1(17); // Cons
A obj2 = 15; // Cons 
/*НЕЯВНЫЙ Конструктор преобразования {Интерпретируется, как A obj2(15)}*/

B obj3(17); // Explicit Cons
B obj4 = 15; // Error

A obj5 = A(25); // Cons
/*
Тоже конструктор преобразования 

В зависимости от оптимизаций компилятора:
 - При наличии оптимизации интерпретируется, как A obj5(25)
 - При отсутствии создаётся временный объект конструктором A(25), запустит конструктор копирования объекта, после чего удалит временный объект
*/
}
```

Следующий конструктор - **конструктор копирования**. Его прототип описывается через ссылочный тип данных: 

```cpp
A(A& v) 
// ИЛИ
A(A const & v) // Предпочтительнее
/* прим. А const === const A, пояснение см. в Дополнительных знаниях */
```

Данный конструктор срабатывает в трёх случаях:
  + При передаче в функцию параметров **по значению** (не по ссылке или указателю);
 - При возврате значений **по значению**;
 + При инициализации одного объекта другим из того же класса (с поправкой на наследования);

При отсутствии явного описания конструктора будет создана его версия **по умолчанию**, производящаяя **плоское копирование** (простое копирование полей один-к-одному), что далеко не всегда обеспечивает корректную работу объектов.

```cpp
struct A {
    A(int x) { std::cout << "Cons" << std::endl; }
	A(const A& other) { std::cout << "Copy" << std::endl; }
};

A dumb_function(A a) {
	ctd::cout << "KWA" << std::endl;
	return a;
}

int main() {
A obj1(1); // Cons
A obj2(obj1); // Copy 

dumb_function(obj1);
/*
Copy
KWA
Copy
*/
}
```

Для **деструктора** нет особых условий срабатывания, он всегда запускается при удалении объекта. Удаление может быть спровоцировано завершением фрейма, содержащего объект (выход из функции, например), завершением программы. Переопределение объекта другим (`A a; A b; a = b;`) не вызывает срабатывание деструктора. По умолчанию также просто добавляется пустой деструктор `~A(){}`. Для множества объектов вызов деструкторов осуществляется в порядке, **обратном их созданию** (т.е. обратом вызову их конструкторов)

Последний обязательный метод - **оператор присваивания**. Немного отходя от основного повествовния, зафиксируем, что в С++ наряду с привычными и пришедшими из С _операциями_ (т.е. какими-то действиями над данными-аргументами) появляются _операторы_ (специальные методы объектов, описывающие реализацию _операций_). Операторы не существуют сами по себе, они принадлежат объектам, описывая некоторый доступный этим объектам функционал. \
Оператор присваивания описывает действия при приравнивании **существующего** объекта некоторому другому существующему объекту того же класса (с поправкой на наследования). Так же, как и конструктор копирования, по умолчанию описывает _плоское приравнивание_.

```cpp
struct A {
    A(int x) { std::cout << "Cons" << std::endl; }
    A(const A& other) { std::cout << "Copy" << std::endl; }
    ~A() { std::cout << "Destr" << std::endl; }
    A& operator=(const A& other) {
		std::cout << "operator=" << std::endl;
		return *this;
	} // Возвращаемое значение по ссылке, чтобы не делать лишнее копирование
};

int main() {
    A obj1(1); // Cons
    A obj2(obj1); // Copy 

    obj1 = obj2; // operator=
} /*
Destr
Destr
*/
```


Несмотря на автоматическое создание конструкторов и деструктора по умолчанию, их ручное описание необходимо для решения задач и организации работы с объектами.

Благодаря механизму перегрузки функций и операторов допустимо описывать множество конструкторов для разных способов создания объекта. Например, для разной обработки входных данных при разном количестве и типах аргументов.

```cpp
struct A {
    A(int x) { std::cout << "Cons1i" << std::endl; }
    A(float x, float y) { std::cout << "Cons2ff" << std::endl; }
    A() { std::cout << "Cons0" << std::endl; }
    ~A() { std::cout << "Destr" << std::endl; }
};

int main() {
    A obj0; // Cons0
    A obj1(1); // Cons1i
    A obj2(2.3, 4.5); // Copy2ff 
} /*
Destr
Destr
Destr
*/
```

Также для большинства объектов недопустимы плоское копирование и присваивание. Для примера собственный класс `String`, представляющий собой обёртку вокруг динамической памяти с char-массивом. Полями класса будут длина текущей строки в памяти, а также указатель на динамическую память с данными. Логично, что обычное плоское копирование или присваивание в таком случае не подойдут, поскольку передав указатель на одну и ту же память другому объекту мы не получим два независимых набора данных. Очевидной проблемой (даже не затрагивая какую-либо работу со сторокой) будет, как минимум, проблема двойного очищения памяти при удалении объектов. Поэтому необходимо описать алгоритмы аллокации памяти и копирования **данных**, а не указателя на них.

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

class String {
    int len;
    char* str;

public:
    String(int bytes = 1): len(bytes), str(new char[bytes]) {str[0] = '\0';}
    // можно убрать по умолчанию

    String(char const * s): len(strlen(s) + 1), str(new char[strlen(s) + 1]){
        for (int i = 0; i < len; i++) {
            str[i] = s[i];
        } 
    }

    String(const String& other): len(other.len), str(new char[other.len]) {
        snprintf(str, len, "%s", other.str);
    }

    String operator=(String const & other) {
        delete [] str;
        len = other.len;
        str = new char[len];

        snprintf(str, len, "%s", other.str);
        return *this;
    }

    ~String() {
        delete [] str;
    }

    void print() {
        std::cout << str;
    }
};


int main() {
    String s1 = "Hello, World!";
    String s2(s1);
    String s3;

    std::cout << "<"; s1.print(); std::cout << ">" << std::endl; // <Hello, World!>
    std::cout << "<"; s2.print(); std::cout << ">" << std::endl; // <Hello, World!>
    std::cout << "<"; s3.print(); std::cout << ">" << std::endl; // <>
}

```

# Перегрузки операторов и дружественные функции

