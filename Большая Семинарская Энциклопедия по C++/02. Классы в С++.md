Вместе с приходом в язык парадигмы ООП появилась возможность создания собственных объектов - ***классов***. Класс описывает некий объект, его поля и методы, задаёт механизмы взаимодействия / иерархии и т.д.

Для описания класса используются ключевые слова `class` и `struct`. Да, в С++ пропадает привычное понимание структуры, как объединения под общим именем нескольких данных. теперь этим ключевым словом также описывается объект. 

Разница между `class` и `struct` заключается в уровне доступа к данным класса. В С++ существует три типа доступа к данным: `private`, `protected`, `public`. `private`-данные доступны только для самого объекта и могут использоваться только в его методах. `protected`-данные доступны для самого объекта и его прямых наследников (к этому уровню доступа мы вернёмся только в главах с наследованием, пока просто знаем, что оно существует). `public`-данные доступны всем объектами могут быть использованы в любом месте, где определены и существуют. В классах, объявленных через `class`, для всех объектов (если не сказано иное) установлен `private`-доступ, для объявленных через `struct` - `public`-доступ.

```cpp
class A {
	// По умолчанию private
public:
	// С этого места всё public
};

struct B {
	// По умолчанию public
private:
	// С этого места всё private
};
```

```cpp
class A {
    int a;
public:
    
    void set_a(int x) {
        a = x;
    }

    int get_a() {
        return a;
    }
};

int main() {
    A obj; // класс А, экземпляр класса (объект класса) obj
    obj.set_a(17);
    std::cout << obj.get_a() << std::endl;
}
```


# Конструкторы и деструкторы

Для описания объектов необходимо, как минимум, описать два основных метода (вернее, два "набора" методов) - ***Конструктор*** и ***Деструктор***. Первый описывает действия, сопутствующие созданию объекта, второй - уничтожению объекта. Если быть более точным, на момент выполнения конструктора **уже существует память**, выделенная под него, **определены поля и методы** класса объекта, объект как бы существует для самого себя (и выполнения своего конструктора, соответственно), но ещё не существует для всей программы. При выполнении деструктора объект выполняет указанный алгоритм, после чего уничтожается.

Вообще говоря, конструкторы-деструкторы есть не только у описываемых нами вручную классов, а вообще у всех объектов. Для встроенных типов нам всего лишь недоступен исходный код их реализации (соответственно, посмотреть или изменить их конструкторы-деструкторы мы не можем).

Для описания объектов **в обязательном порядке** регламентируются ***два вида конструкторов, оператор присваивания и деструктор.*** Отсутствие явного определения или указания относительно любого из них компилятором воспринимается, как указание создания **метода по умолчанию**. Имена конструкторов и деструктора совпадают с названием класса объекта.

Первый вид конструктора - **конструктор преобразования**. Он срабатывает в момент инициализации объекта параметрами (или без них). Конструктор может иметь параметры или не иметь их, сами параметры могут иметь значения по умолчанию.  При отсутствии хотя бы какого-то конструктора преобразования (с параметрами или без), **по умолчанию** автоматически создастся **пустой конструктор**.

```cpp
class A {
    int a;
public:
    A(int x = 0): a(x) {} // можно делать значения по умолчанию
    
    int get_a() {
        return a;
    }
};

int main() {
    A obj(17); // конструктор преобразования
    A obj2; // Конструктор со значением по умолчанию
    std::cout << obj.get_a() << ' ' << obj2.get_a()<< std::endl; // 17 0
}
```

В конструкции кода, описывающего любой конструктор, существует специальная область, ограниченная закрывающейся скобкой аргументов и открывающейся скобкой тела конструктора - ***область инициализации***. В ней описываются связанные с работой данного конструктора действия конструкторов иерархически более низкого уровня, выполняющиеся непосредственно перед выполнением тела конструктора (например, конструкторы полей объекта; в коде выше как раз такой случай, поле `a` вызывает свой конструктор от аргумента `x` (ещё одно доказательство, что, вообще говоря, всё в С++ - объекты) )

При описании конструктора с одним параметром компилятор позволяет использовать _неявный_ конструктор преобразования. Избежать этого позволит явное указание запрета неявных преобразований с помощью ключевого слова `explicit`

```cpp
struct A {
    A(int x) { std::cout << "Cons" << std::endl; }
};

struct B {
    explicit B(int x) { std::cout << "Explicit Cons" << std::endl; }
};

int main() {
A obj1(17); // Cons
A obj2 = 15; // Cons 
/*НЕЯВНЫЙ Конструктор преобразования {Интерпретируется, как A obj2(15)}*/

B obj3(17); // Explicit Cons
B obj4 = 15; // Error

A obj5 = A(25); // Cons
/*
Тоже конструктор преобразования 

В зависимости от оптимизаций компилятора:
 - При наличии оптимизации интерпретируется, как A obj5(25)
 - При отсутствии создаётся временный объект конструктором A(25), запустит конструктор копирования объекта, после чего удалит временный объект
*/
}
```

Следующий конструктор - **конструктор копирования**. Его прототип описывается через ссылочный тип данных: 

```cpp
A(A& v) 
// ИЛИ
A(A const & v) // Предпочтительнее
/* прим. А const === const A, пояснение см. в Дополнительных знаниях */
```

Данный конструктор срабатывает в трёх случаях:
  + При передаче в функцию параметров **по значению** (не по ссылке или указателю);
 - При возврате значений **по значению**;
 + При инициализации одного объекта другим из того же класса (с поправкой на наследования);

При отсутствии явного описания конструктора будет создана его версия **по умолчанию**, производящаяя **плоское копирование** (простое копирование полей один-к-одному), что далеко не всегда обеспечивает корректную работу объектов.

```cpp
struct A {
    A(int x) { std::cout << "Cons" << std::endl; }
	A(const A& other) { std::cout << "Copy" << std::endl; }
};

A dumb_function(A a) {
	ctd::cout << "KWA" << std::endl;
	return a;
}

int main() {
A obj1(1); // Cons
A obj2(obj1); // Copy 

dumb_function(obj1);
/*
Copy
KWA
Copy
*/
}
```

Для **деструктора** нет особых условий срабатывания, он всегда запускается при удалении объекта. Удаление может быть спровоцировано завершением фрейма, содержащего объект (выход из функции, например), завершением программы. Переопределение объекта другим (`A a; A b; a = b;`) не вызывает срабатывание деструктора. По умолчанию также просто добавляется пустой деструктор `~A(){}`. Для множества объектов вызов деструкторов осуществляется в порядке, **обратном их созданию** (т.е. обратом вызову их конструкторов)

Последний обязательный метод - **оператор присваивания**. Немного отходя от основного повествовния, зафиксируем, что в С++ наряду с привычными и пришедшими из С _операциями_ (т.е. какими-то действиями над данными-аргументами) появляются _операторы_ (специальные методы объектов, описывающие реализацию _операций_). Операторы не существуют сами по себе, они принадлежат объектам, описывая некоторый доступный этим объектам функционал. \
Оператор присваивания описывает действия при приравнивании **существующего** объекта некоторому другому существующему объекту того же класса (с поправкой на наследования). Так же, как и конструктор копирования, по умолчанию описывает _плоское приравнивание_.

```cpp
struct A {
    A(int x) { std::cout << "Cons" << std::endl; }
    A(const A& other) { std::cout << "Copy" << std::endl; }
    ~A() { std::cout << "Destr" << std::endl; }
    A& operator=(const A& other) {
		std::cout << "operator=" << std::endl;
		return *this;
	} // Возвращаемое значение по ссылке, чтобы не делать лишнее копирование
};

int main() {
    A obj1(1); // Cons
    A obj2(obj1); // Copy 

    obj1 = obj2; // operator=
} /*
Destr
Destr
*/
```


Несмотря на автоматическое создание конструкторов и деструктора по умолчанию, их ручное описание необходимо для решения задач и организации работы с объектами.

Благодаря механизму перегрузки функций и операторов допустимо описывать множество конструкторов для разных способов создания объекта. Например, для разной обработки входных данных при разном количестве и типах аргументов.

```cpp
struct A {
    A(int x) { std::cout << "Cons1i" << std::endl; }
    A(float x, float y) { std::cout << "Cons2ff" << std::endl; }
    A() { std::cout << "Cons0" << std::endl; }
    ~A() { std::cout << "Destr" << std::endl; }
};

int main() {
    A obj0; // Cons0
    A obj1(1); // Cons1i
    A obj2(2.3, 4.5); // Copy2ff 
} /*
Destr
Destr
Destr
*/
```

Также для большинства объектов недопустимы плоское копирование и присваивание. Для примера собственный класс `String`, представляющий собой обёртку вокруг динамической памяти с char-массивом. Полями класса будут длина текущей строки в памяти, а также указатель на динамическую память с данными. Логично, что обычное плоское копирование или присваивание в таком случае не подойдут, поскольку передав указатель на одну и ту же память другому объекту мы не получим два независимых набора данных. Очевидной проблемой (даже не затрагивая какую-либо работу со сторокой) будет, как минимум, проблема двойного очищения памяти при удалении объектов. Поэтому необходимо описать алгоритмы аллокации памяти и копирования **данных**, а не указателя на них.

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

class String {
    int len;
    char* str;

public:
    String(int bytes = 1): len(bytes), str(new char[bytes]) {str[0] = '\0';}
    // можно убрать по умолчанию

    String(char const * s): len(strlen(s) + 1), str(new char[strlen(s) + 1]){
        for (int i = 0; i < len; i++) {
            str[i] = s[i];
        } 
    }

    String(const String& other): len(other.len), str(new char[other.len]) {
        snprintf(str, len, "%s", other.str);
    }

    String operator=(String const & other) {
        delete [] str;
        len = other.len;
        str = new char[len];

        snprintf(str, len, "%s", other.str);
        return *this;
    }

    ~String() {
        delete [] str;
    }

    void print() {
        std::cout << str;
    }
};


int main() {
    String s1 = "Hello, World!";
    String s2(s1);
    String s3;

    std::cout << "<"; s1.print(); std::cout << ">" << std::endl; // <Hello, World!>
    std::cout << "<"; s2.print(); std::cout << ">" << std::endl; // <Hello, World!>
    std::cout << "<"; s3.print(); std::cout << ">" << std::endl; // <>
}

```

# Перегрузки операторов и дружественные функции


Для реализации некоторых операций неудобно использовать обычные методы классов, хочется унифицировать формат работы схожих операций при помощи известных операторов. Но, логично, для реализованных нами классов простое использование операторов работать не будет, необходимо описать алгоритм действий в рамках реализации этих операторов. Также при работе с некоторыми классами, для которых уже реализованы некоторые операторы, возможно описать дополнительно обработку для других входных данных (других аргументов) того же оператора. Все эти действия называются ***перегрузкой операторов***. Механизм перегрузки и то, на чём он основан, будут обсуждены нами далее в соответсвующем разделе, посвящённом перегрузкам. Здесь мы обсудим лишь базовые моменты.

Среди всех операторов перегрузить нельзя:
 + Оператор действий препроцессора `#`
 + Оператор расширения области видимости `::`
 + Тернарный оператор `?:`
 + Оператор доступа к полям `.`
 + Оператор определения типа `typeid`
 + Оператор определения размера объекта `sizeof`

Ниже представлен пример **перегрузки операции сравнения** для класса комплексных чисел в сравнении с реализацией того же самого сравнения через метод:

```cpp
class C {
    double re, im;

public:
    C(double x = 0.0, double y = 0.0): re(x), im(y) {}
    bool ifEqual(C& obj); //прототип
};

bool C::ifEqual(C& obj) {
    return re == obj.re && im == obj.im;
}

int main() {
    C o1(1, 2), o2(3);
    if (o1.isEqual(o2)) {
        std::cout << "Равны\n";
    }
}
```

```cpp
class C {
    double re, im;

public:
    C(double x = 0.0, double y = 0.0): re(x), im(y) {}
    bool operator==(C& obj); //прототип
};

bool C::operator==(C& obj) {
    return re == obj.re && im == obj.im;
}

int main() {
    C o1(1, 2), o2(3);
    if (o1==o2) {
        std::cout << "Равны\n";
    }
}

```

Как видно, перегрузка функций упрощает и унифицирует синтаксис программы, делая её простой для чтения и отладки.

Продолжим описывать класс комплексных чисел, и на его примере разберём перегрузки оасновных операторов.

```cpp
class C {
    double re, im;

public:
    C(double x = 0.0, double y = 0.0): re(x), im(y) {}
    
    bool operator==(const C& obj) {
        return re == obj.re && im == obj.im;
    }
}
```

У нас уже имеется конструктор (причём указание для обоих параметров значений по умолчанию позволяет создавать нам объекты с любым - нулём, одним или двумя - количеством параметров). Конструктор копирования **конкретно в реализации этого класса** может быть оставлен по умолчанию, поскольку плоское копирование полей нам более чем устраивает. Также и деструктор может быть оставлен сгенерированнным по умолчанию.

Пример перегрузки операции сравнения уже сделан, к другим операциям сравнения вернёмся позже, а сейчас рассмотрим базовые арифметические операции на примере сложения.

Потенциально необходимо реализовать операции сложения двух комплексных чисел, а также комплексного с просто вещественным:

```cpp
int main() {
	C o1(1, 2), o2(3, 4), o3;

	o3 = o1 + o2;
	o3 = o1 + 1.2;
	o3 = 1.4 + o2;
}
```

Для первого выражения опишем аналогичный операции сравнения оператор сложения, создающий на основе текущих объектов новый, описывающий их сумму:

```cpp
С operator+(C& obj) {
	return C(re + x.re, im + x.im);
}
```

Однако такая конструкция не сработает для второго выражения, поскольку константный объект _"вещественная константа"_ никак не воспримется компилятором как изменяемый объект "экземпляр класса комплексных чисел". Можно описать отдельную обработку для оператора под такой аргумент ( `С operator+(double obj)` ), однако в более сложных проектах такая обработка будет требовать описания огромного количества однотипных перегрузок. Правильным способом обработки будет использование возможности неявного конструктора преобразования для константы, для его срабатывания необходимо добавить константность аргументу оператора:

```cpp
С operator+(C const & obj) {
	return C(re + x.re, im + x.im);
}
```

Но даже при таком использовании в программе не скомпилируется третье выражение. \
Вообще говоря, инфиксная запись `o1 + o2` является _синтаксическим сахаром_ для реального выражения `o1.operator+(o2)`. Отсюда становится очевидным неработоспособность в третьем случае: в классе `double` не реализован оператор сложения с комплексными числами. \
В таком случае необходимо использовать ***дружественные функции*** - это функции, не принадлежащие классу непосредственно (не являющиеся его методами (могут быть глобальными или, например, методами другого класса) ), которым доступны закрытые члены этого класса. Они объявляются внутри класса, их параметры **обязательно** являются объектами класса. Принято все операции, не меняющие объекты аргументы, реализовывать именно через дружественные функции. Исключениями являются только операторы индексации `[]`, "исполнимости" (_callable_ object) `()`и присваивания `=`.

В итоге, мы получим дружественную функцию сложения:

```cpp
friend C operator+(C const & a, C const & b) {
	return C(a.re + b.re, a.im + b.im);
}
```

Вспомним про оставленные нами операции сравнения. Понятно, что правильнее реализовывать их через дружественные функции (хотя никто не мешает нам реализовать их и через чистые перегрузки `<` и `>`, особенно если сравнивать их с объектами других классов в любом порядке (как было с `double` при сложении) мы не собираемся). Здесь хочется указать на две вещи:
 + Необходимо явно определять параметр, по которому будет проводиться сравнение, например, ввести функцию взятия модуля комплексного числа и использовать её:
```cpp
friend double abs(C const & a) {
	return sqrt(a.re * a.re + a.im * a.im); // #include <cmath>
}
```
 + Возможно реализовать одни функции сравнения через другиес помощью смены замены местами параметров и / или отрицаний:
```cpp
friend bool operator<(C const & a, C const& b) {
	return abs(a) < abs(b);
}

friend bool operator>(C const & a, C const& b) {
	return b < a;
}

friend bool operator<=(C const & a, C const& b) {
	return !(b < a);
}
```

***TODO: Самостоятельно исправить оператор == для его работы в с любыми элементами***

Операции ввода-вывода с помощью операторов битовых сдвигов `<< >>` описываются только с помощью дружественных функций:

```cpp
friend std::istream & operator>>(std::istream & o, C& obj) {
	o >> obj.re >> obj.im;
	return o;
}

friend std::ostream & operator<<(std::ostream & o, C const & obj) {
	o << obj.re << " " << obj.im << std::endl;
	return o;
}
```

В случае использования сокращённых форм операций `+=` происходит явное изменение первого аргумента, поэтому необходимо использовать перегрузку оператора (при этом, так как мы не хотим пересоздать объект, а хотим изменить текущий, воспользуемся **возвращением результата по ссылке** - к объекту вернётся он же, никаких переприсваиваний и лишних созданий-удалений объектов не будет)

```cpp
C& operator+=(C const & a) {
	re += a.re;
	im = a.im;
	return *this;
}
```

	Уже не в первый раз в коде возникает волшебная запись *this. this - указатель на текущий объект для обращения к нему же в его методах. Соответственно, сам объект можно использовать, разыменовав указатель.

Отдельным образом обрабатываются инкремент и декремент для объектов, поскольку на первый взгляд они представляют собой один набор операций (`изменение текущего объекта` И `возврат элемента`) от одного и того же количества аргументов (просто от текущего объекта), однако порядок операций в корне меняют логику и, следовательно, реализацию этих операций.

В случае префиксной операции объект **сначала производит изменение** себя, только **после возвращает объект**, следовательно, для уменьшения лишних созданий объектов возможно по ссылке возвращать сам изменённый объект.

```cpp
C& operator++() {
	re++;
	im++;

	return *this;
}
```

В случае постфиксной операции сначала необходимо вернуть неизменённый объект, а лишь затем его изменить. Очевидно, написать `return` вперёд реализации невозможно, поэтому создаётся отдельный временный объект - копия текущего, над текущим производится изменение, после чего возвращается неизменённая копия. Для отличия операторов в постфиксном используется фиктивный аргумент:

```cpp
C operator++(int NotUsed) {
	C tmp(re, im);
	re++;
	im++;

	return tmp;
}
```

Именно по этой причине использование префиксных операций оптимальнее постфиксных, поскольку это гарантированно уменьшает количество лишних созданий-удалений временных объектов.

Рассмотрим операцию присваивания. Как можно было заметить в примерах выше, когда обсуждались основные методы классов, у оператора существует возвращаемое значение. Сделано это не просто так, а для возможности множественного присваивания. При объявлении функции `void` нечему будет присваиваться в повторных операциях.

```cpp
C& operator=(C const & a) {
	re = a.re;
	im = a.im;
	return *this;
}
```

Последняя операция, рассматриваемая в данном блоке - приведение типов. Через конструктор в нашем классе уже существует приведение вещественных чисел к комплексным. Аналогичным образом через описание оператора приведения типа можно реализовать обратный перевод.

```cpp
operator double() {
	return re;
}
```

***ВАЖНО:*** хоть синтаксис и похож на описание конструктора для типа `double`, это именно **оператор приведения**, конструкторы встроенных типов изменять и модифицировать мы не можем.

Из-за наличия приведений как C->double, так и double->C, без явного указания в некоторых случаях компилятор не может определить, какие действия необходимо произвести, поскольку для него оба преобразования равнозначны (связано это вновь с механизмом перегрузок, который будет рассмотрен в следующей главе):

```cpp
double x = 15, y;

/*
y = o1 + x; // неопределённость компилятора, error
y = x + o1; // неопределённость компилятора, error
*/

y = double(o1) + x;
y = o1 + C(x);
```

Объединяя все вышеописанные блоки получим вполне рабочую версию класса комплексных чисел (Для работы элементов без явного указания преобразований из общей программы исключён оператор приведения типов)

```cpp
#include <iostream>
#include <cmath>

class C {
    double re, im;

public:
    C(double x = 0.0, double y = 0.0): re(x), im(y) {}
    
    bool operator==(const C& obj) {
        return re == obj.re && im == obj.im;
    }

//--

    C operator+(C const & x) {
        return C(re + x.re, im + x.im);
    }

/*Правильнее вместо верхнего, тогда будет работать 3ий вариант*/

    friend C operator+(C const & a, C const & b) {
        return C(a.re + b.re, a.im + b.im);
    }

//--

    friend double abs(C const & a) {
        return sqrt(a.re * a.re + a.im * a.im); // #include <cmath>
    }

    friend bool operator<(C const & a, C const& b) {
        return abs(a) < abs(b);
    }

    friend bool operator>(C const & a, C const& b) {
        return b < a;
    }

    friend bool operator<=(C const & a, C const& b) {
        return !(b < a);
    }

//--

/* ввод-вывод - только как дружественные*/

    friend std::istream & operator>>(std::istream & o, C& obj) {
        o >> obj.re >> obj.im;
        return o;
    }

    friend std::ostream & operator<<(std::ostream & o, C const & obj) {
        o << obj.re << " " << obj.im << std::endl;
        return o;
    }

//--

    C& operator+=(C const & a) {
        re += a.re;
        im = a.im;
        return *this;
    }

//--

    C operator -() {
        return C(-re, -im);
    }

//--

    C& operator++() {
        re++;
        im++;

        return *this;
    }

    C operator++(int NotUsed) {
        C tmp(re, im);
        re++;
        im++;

        return tmp;
    }

//--
    
    C& operator=(C const & a) {
        re = a.re;
        im = a.im;
        return *this;
    }
  
};

int main() {
    C o1(1, 2), o2(3, 4), o3;

    o3 = o1 + o2;   // работает во всех случаях реализации
    o3 = o1 + 1.2;  // не работает без const. Чтобы был конструктор преобразования от константы, нужно добавить аргументу const
    o3 = 1.4 + o1;  // не работает без дружественной функции, тк double не умеет складывать себя с С

    std::cout << (o1 < o2) << " " << (o3 <= 1.4) << " " << (2.3 > o3) << std::endl;

    std::cin >> o3;
    std::cout << o3;

    o3 += o1;

    o3 = -o1;

    o3 = ++o1; // no parameter
    o3 = o1++; // with parameter
    o3 = ++++o1; //++(++o1) тк работает справа налево; o3 = (3, 4), o1 = (3, 4)
    o3 = o1++++; // o1 = (2, 3), o3 = (1, 2)

    o3 = o1;
    o3 = o1 = o2; // Не будет работать, если возвращаемое значение будет void
}
```

---

С новыми знаниями дополним класс String:

```cpp
#include <iostream>
#include <cstring>

class String {
    int len;
    char* str;

public:
    String(int bytes = 1): len(bytes), str(new char[bytes]) {str[0] = '\0';}
    
    String(char const * s): len(strlen(s) + 1), str(new char[strlen(s) + 1]) {
        for (int i = 0; i < len; i++) {
            str[i] = s[i];
        } 
    }

    String(String& other): len(other.len), str(new char[other.len]) {
        snprintf(str, len, "%s", other.str);
    }

    String operator=(String const & other) {
        
        if (this == &other) {
            return *this;
        }

        delete [] str;
        len = other.len;
        str = new char[len];

        snprintf(str, len, "%s", other.str);
        return *this;
    }

    friend String operator+(String const& s1, String const& s2) {
        String tmp(s1.len + s2.len - 1);

        snprintf(tmp.str, tmp.len, "%s%s", s1.str, s2.str);
        return tmp;
    }

    void print() {
        std::cout << str << std::endl;
    }

    ~String() {
        delete [] str;
    }

};

int main() {
    String s1("abc"), s2("cdef"), s3;

    s3 = s1;
    s3.print();

    s1 = s1;
    s1.print();

    s3 = s1 + s2;
    s3.print();
}
```

