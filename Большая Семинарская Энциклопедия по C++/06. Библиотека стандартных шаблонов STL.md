`Standart Template Library` - целый кластер библиотек, позволяющий достаточно унифицированным способом использовать шаблонные объекты для обработки данных.

#### Базовая классификация

Весь функционал библиотеки можно разбить на три больших блока:
 + ***Контейнеры*** - основной блок объектов, предоставляемый разные способы хранения данных:
	 + **Последовательности**:
		 + _Базовые_:
			 + `vector` (динамический массив)
			 + `array` (фиксированный массив)
			 + `list` (двурнаправленный список)
			 + `deque` (дека - двунаправленная очередь)
		 + _Производные_:
			 + `stack` (на основе вектора)
			 + `queue` (на основе деки)
	 + **Ассоциативные массивы**:
		 + _В виде деревьев_:
			 + `map` / `multimap` (словарь ключ-значение, детерминированный (ключ единственный) / недетерминированный (ключи могут повторяться))
			 + `set` / `multiset` (множество детерминированное / недетерминированное)
		 + _В виде `hash`-таблиц_:
			 + `unordered_map` / `unordered_multimap` (словарь ключ-значение, детерминированный (ключ единственный) / недетерминированный (ключи могут повторяться))
			 + `unordered_set` / `unordered_multiset` (множество детерминированное / недетерминированное)
 + ***Итераторы*** - основной объект, используемый для взаимодействия с данными контейнеров. По структуре итератор является надстройкой для указателя на данные.
 + ***Алгоритмы***, поддерживающие множество возможностей обработки шаблонов

#### Типы итераторов

Итераторы для разных объектов-контейнеров по структуре и функционалу делятся на пять групп, каждая следующая из которых включает функционал предыдущей (более точно: 4 вида имеют зависимость, к ним добавлен отдельно стоящий `output`).

 + `output`
 + `input`
	 + `forward`
		 + `bidirectional`
			 + `random_access`

`Output`  итератор можно разыменовывать в левой части выражений:

```cpp
*a = t;
```

`Input` итераторы можно сравнивать с помощью операторов `==` и `!=`. Каждый следующий подкласс `Input` итератора расширяет функционал:
 + `Forward Iterator` могут выполнять роль `Output` итератора. Итераторы этого типа используются для перебора элементов с помощью оператора инкремента `++`.
 + `Bidirectional Iterator` позволяет дополнительно к функционалу `Forward Iterator` использовать оператор декремента `--` и перебирать последовательность в обратном направлении.  к `bidirectional` относятся итераторы `list`, `map`, `set`.
 + `Random access Iterator` позволяет получить доступ к произвольному элементы диапазона по индексу `[]`, поддерживают операторы сравнения `<`, `<=`, `>`, `>=` и арифметические операторы `+` и `-`. Такой тип у итераторов `vector` и `deque`.

Для работы с итераторами у **каждого** контейнера есть 8 базовых метода их создания (4 описанных и аналогичные им для константных объектов):
 + `begin()` / `cbegin()` - итератор на первый элемент // `iterator`
 + `end()` / `cend()` - Итератор на элемент за последним (если контейнер пустой, то `begin() == end()`)
 + `rbegin()` / `crbegin()` - итератор на последний элемент // `reverse_iterator`
 + `rend()` / `crend()` - Итератор на элемент перед первым (если контейнер пустой, то `rbegin() == rend()`)

```
Зачем обратные итераторы:

для reverse_iterator инвертированы не только места определения, но и основные направления действия: при увеличении обратного итератора он перемещается назад по объекту, благодаря чему можно унифицировать обработку какой-либо последовательности, не ориентируясь на направление обхода, а просто проверяя достижение (или недостижение) конца контейнера по итератору
```

```cpp
for (std::vector<int>::iterator it = v4.begin(); it != v4.end(); it++) {
    std::cout << *it;
}

for (std::vector<int>::reverse_iterator it = v4.rbegin(); it != v4.rend(); it++) {
    std::cout << *it;
}
```

По типам можно понять, с какими контейнерами (не ниже нашего) и в каком формате мы можем работать заданным итератором. Лайфхаки по работе с итераторами описаны в Дополнительных знаниях.

#### Унифицированный функционал

Почти наверное все контейнеры поддерживают унифицированный функционал относительно работы с ними:
 + `value_type` - тип значения данных в шаблоне
 + `size_type` - (как `size_t`) тип размера объекта-контейнера
 + Ссылочный тип для данных контейнера:
	 + `reference`
	 + `const_reference`
 + Указательный тип для данных контейнера:
	 + `pointer`
	 + `const_pointer`
 + Итераторы:
	 + `iterator` - прямой итератор (от начала до конца)
	 + `reverse_iterator` - обратный итератор (от конца к началу)
	 + `const_iterator` 
	 + `const_reverse_iterator`

Большинство контейнеров поддерживают унифицированный базовый набор методов для работы:

```cpp
size_t size(); // размер контейнера

bool empty(); // проверка на пустоту
void clear(); // отчистить контейнер, НО сохранить capacity (выделенное на него место)

/*для контейнеров последовательности*/
void push_back(<value>); // добавить значение в конец
void pop_back(); // удаляет последний элемент, не возвращая

reference back(); // возврат ссылки на последний элемент
reference front(); // возврат ссылки на первый элемент

iterator insert(iterator p, <value>); // вставляет ПЕРЕД итератором значение и возвращает следующий за ним

/* При работе с контейнерами последовательности все итераторы и т.п. могут потеряться, т.к. может произойти перевыделение памяти*/

iterator erase(iterator p); // удаляет по итератору, всё сдвигает и возвращает итератор на следующий элемент
```


#### Полезные ссылки

Для более подробного исследования контейнеров собрал быстрые ссылки на хорошие ресуры:
 + [GeekForGeeks](https://www.geeksforgeeks.org/the-c-standard-template-library-stl/) - Классический ресурс, на котором написано много, подробно, а, главное, часто обновляемо
 + [CppReference](https://en.cppreference.com/w/cpp/container) - Практически `man` по С++. Самый полный и самый строгий в формулировках и информации ресурс
 + [Microsoft Learn](https://learn.microsoft.com/ru-ru/cpp/standard-library/cpp-standard-library-reference?view=msvc-170) - Лично для меня самый удобный материал: есть удобное оглавление в виде дерева, для каждого контейнера в начале статей написана табличка поддерживаемых методов и краткое описание, можно, не листая, быстро найти нужный функционал и его использоавть.