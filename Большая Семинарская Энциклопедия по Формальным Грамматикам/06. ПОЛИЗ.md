Результатом работы синтаксического анализатора должно быть некоторое внутреннее представление исходной программы, по которой понятен её синтаксис, для дальнейшей сборки исполняемого файла или интерпретации. В качестве промежуточного представления языка часто используют постфиксную или префиксную записи, при которых операция указывается после (перед) операндами. 

В курсе СП разбирается ПОЛьская Инверсная Запись - специальный вид постфиксной записи, поддерживающий запись для условий, циклов, функций. Выполнение ПОЛИЗ-выражения аналогично любому постфиксному выражению: при считывании операндов они записываются на стек, а при считывании операции нужное для неё количество операндов снимается со стека, производится вычисление, и его результат вновь помещается на стек. 

Напомним, что для ПОЛИЗ, как и для любой записи выражения последовательность операндов играет роль и не должна нарушаться, даже если это не повлияет на результат выражения (например, `a+b` и `b+a` считают одинаковый результат, однако считаются **разными** выражениями) 

# Трансляция выражений в ПОЛИЗ

Разберём на примерах трансляцию инфиксных выражений (выражений, в которых операция находится между / объединена с операндами) в ПОЛИЗ
 + Символика элементов, предлагаемых в методичке, отличается от используемой далее, однако на деле оказывается понятнее и, если ваши семинаристы не скажут обратное, разрешена официально на экзамене и коллоквиуме 
 + Некоторые символы ***не компилируются*** на `github`, вследствие чего заменены уже второй раз от тех обозначений, которые имеются в виду:
	 + При разговоре о символе взятия адреса (амперсанд) вместо него будет написан символ $\eth$ 
	 + При разговоре о декрементах и инкрементах обозначения постфиксного и префиксного вариантов выделяются символом хэштега (решётка), но вместо него будет написан $\nparallel$ 

## Вычислительные операции

 + Будем называть _простым_ выражение, состоящее из одной константы или имени переменной. Если инфиксное выражение `E` является простым выражением, то его ПОЛИЗ - это само выражение: $Poliz(E) \equiv E$;

 + Для бинарных операций ПОЛИЗ имеет вид $Poliz(E_1\ \theta\ E_2) \equiv Poliz(E_1)\ Poliz(E_2)\ \theta$.  Для унарных операций $Poliz(\theta\ E) \equiv Poliz(E)\ \theta$. Для унарных операций, имеющих бинарную интерпретацию (унарный минус, унарный плюс), существуетдва варианта обработки: **либо** их трансформируют в бинарные (-а $\equiv$ 0-а),  **либо** используем замену знаков (для унарного минуса принято использовать знак `@`: $Poliz(-a) \equiv a\ @$)

 + Скобки в ПОЛИЗ опускаются, последовательность операций определяется их порядком в итоговой записи: $Poliz((E)) \equiv Poliz(E)$  

 + В случае описывания функций сначала описываются её операнды в прямой последовательности, а после пишется сама функция

	Примеры трансляций: 
	 + $Poliz(a-b-c) \equiv a\ b\ -\ c\ -$
	 + $Poliz(a-(b-c)) \equiv a\ b\ c\ -\ -$
	 + $Poliz(-a * -(b+c)) \equiv a\ @\ b\ c\ +\ @\ *$

 + ПОЛИЗ в рамках курса проходится для трансляции Си-выражений. В Си нет **оператора** присваивания, но есть бинарная **операция** присваивания, записывающая по адресу первого операнда значение второго операнда, а также возвращая это значение на стек. Это обусловлено возможностью множественного присваивания. Поэтому неиспользуемое значение со стека необходимо сбрасывать, для этого используется дополнительный символ $;$ \
   Так как целевой операнд должен принимать значение по адресу, при трансляции он помечается знаком взятия адреса $\eth$ (в дальнейшем при подсчёте элементов ПОЛИЗ элемент вида $\eth a$ будет считаться за один, а не за два) \
   Обработка вычисляющих присваиваний (`+=`, `-=` и т.д.) аналогична
	 + $Poliz(a = B;) \equiv \eth a\ B\ =\ ;$
	 + $Poliz(a = b = c;) \equiv \eth a\ \eth b\ c\ =\ =\ ;$ (Присваивание - правоассоциативная операция, обрабатывается справа налево)
   
 + Инкремент и декремент также являются операциями, поэтому для них такжxе необходима очистка стека. Здесь также происходит запись значения, поэтому операнд будет записываться с указанием взятия адреса. \
   Для различимости операций префиксного и постфиксного инкремента и декремента используются специальные обозначения: $\nparallel+$ и $\nparallel-$ для постфиксных  операций, $+\nparallel$ и $-\nparallel$ - для префиксных (при подсчёте элементов они также считаются едиными).
	 + $Poliz(a++;) \equiv \eth a\ \nparallel+\ ;$ 
	 + $Poliz(c = --b;) \equiv \eth c\ \eth b\ -\nparallel\ =\ ;$ 

 + Операция `,` в Си позволяет проводить множество несвязанных блоков в одном выражении, возвращаемым значением делая результат последнего. В ПОЛИЗ это будет приравниваться сбросу значения блока со стека
    + $Poliz(x = a+b, a*b;) \equiv \eth x\ a\ b\ +\ ;\ a\ b\ *\ =\ ;$

Объдиняющий пример: $Poliz(s = i * (--a + b++); ) \equiv \eth s\ i\ \eth a\ -\nparallel\ \eth b\ \nparallel+\ +\ *\ =\ ;$ 

## Условия и циклы

Для реализации операций, в которых так или иначе участвует непоследовательный переход между операциями, используется аналог `goto`-конструкций. В ПОЛИЗ существует два вида таких операций - **безусловный** и **условный** переходы. \
Безусловный переход состоит из двух элементов и имеет вид $\rho\ !$, где вместо $\rho$ пишется номер элемента ПОЛИЗ-выражения, куда совершается переход (именно для этого нам и необходимо будет считать элементы)  \
Условный переход реализовалтолько **по лжи**, состоит из трёх элементов и имеет вид $Expr\ \rho\ !F$, $\rho$ описывает номер элемента, куда переместится исполнитель при отрицательном результате условия. При корректном исполнении перехода не произойдёт, и исполнение выражения просто продолжится дальше.

`Отсюда и далее для выделения одного элемента (в конкретном контексте)` \
`периодически будут использоваться треугольные скобки вида ` $\langle \rangle$ \
`Для разделения элементов в примерах, где необходимо их считать` \
`будут также использоваться разделители вида` $\rfloor\lfloor$ 

---

 Классическое условное выражение вида $if\ (B)\ \langle op_1; \rangle\ else\ \langle op_2; \rangle$ транслируется в ПОЛИЗ $B\ \rfloor\lfloor\ \rho_{else}\ \rfloor\lfloor\ !F\ \rfloor\lfloor\ \langle op_1; \rangle\ \rfloor\lfloor\ \rho_{exit}\ \rfloor\lfloor\ !\ \rfloor\lfloor\ \langle op_2; \rangle\ \rfloor\lfloor\ \langle \rangle$ \
 $\rho_{else}$ должен переносить исполнение на $op_2$ (`else`-реализация), а $\rho_{exit}$ должен после исполнения $op_1$ (`if`-реализация) переносить исполнение далее за условие, т.е. на _фиктивный_ следующий за выражением элемент (для наглядности и подсчёта он указан, однако на деле отсутствует). Итоговый вид ПОЛИЗ имеет с заполненными значениями: $Poliz(if\ (B)\ \langle op_1; \rangle\ else\ \langle op_2; \rangle) \equiv B\ 7\ !F\ \langle op_1; \rangle\ 8\ !\ \langle op_2; \rangle$. Заметим, что в ПОЛИЗ-выражении, как и в изначальном, порядок операндов (условие - `if`-секция -  `else`- секция) **не изменился**. 

Пример: $$
   \begin{aligned}
   &Poliz(\ if((x + 1) > y)\ x = y;\ else\ y = (x-y)*3;\ ) \equiv& \\
   &x\ \rfloor\lfloor\ 1\ \rfloor\lfloor\ +\ \rfloor\lfloor\ y\ \rfloor\lfloor\ >\ \rfloor\lfloor\ \rho_{else}\ \rfloor\lfloor\ !F\ \rfloor\lfloor\ \eth x\ \rfloor\lfloor\ y\ \rfloor\lfloor\ =\ \rfloor\lfloor\ ;\ \rfloor\lfloor\ \rho_{exit}\ \rfloor\lfloor\ !\ \rfloor\lfloor\ \eth y\ \rfloor\lfloor\ x\ \rfloor\lfloor\ y\ \rfloor\lfloor\ -\ \rfloor\lfloor\ 3\ \rfloor\lfloor\ *\ \rfloor\lfloor\ =\ \rfloor\lfloor\ ;\ \rfloor\lfloor\ \langle \rangle\ \equiv & \\
   &x\ 1\ +\ y\ >\ 14\ !F\ \eth x\ y\ =\ ;\ 22\ !\ \eth y\ x\ y\ -\ 3\ *\ =\ ;&
   \end{aligned}
   $$


---

Аналогичным методом описываются циклы `while` и `do-while`:

 + $Poliz(while(\langle Expr \rangle)\ \langle Body \rangle) \equiv \langle Expr \rangle\ \rho_{exit}\ !F\ \langle Body \rangle\ \rho_{return}\ !$, $\rho_{exit}$ описывает номер элемента после цикла для условного перехода выхода из цикла по невыполнению условия, $\rho_{return}$ - номер элемента условия для возврата после итерации исполнения тела

 + $Poliz(do\ \langle Body \rangle\ while(\langle Expr \rangle)) \equiv \langle Body \rangle\ \langle Expr \rangle\ \rho_{exit}\ !F\ \rho_{return}\ !$

Примеры:

$$
\begin{aligned}
&Poliz(\ while(i < 9) \text{\{} s\ += f(i * 2);\ i++;\}\ ) \equiv & \\
&i\ 9\ <\ 18\ !F\ \eth s\ i\ 2\ *\ f\ +=\ ;\ \eth i\ \nparallel+\ ;\ 1\ !&
\end{aligned}
$$

$$
\begin{aligned}
&Poliz(\ do\text{\{} x = z = (x - y - 5) * b - 3 / k; b++;\}\ while(-x + y > 0)) \equiv & \\
&\eth x\ \eth z\ x\ y\ -\ 5\ -\ b\ *\ 3\ k\ /\ -\ =\ =\ ;\ \eth b\ \nparallel+\ ;\ x\ @\ y\ +\ 0\ >\ 30\ !F\ 1\ !&
\end{aligned}
$$

---

При реализации цикла `for` необходимо соблюдать порядок элементов: Преамбула - Условие - Шаги итераторов - Тело. Даже при отсутствии какого-то из элементов необходимо сохранять структуру цикла: \
$$
\begin{aligned}
&Poliz( for(\langle Preambule \rangle;\ \langle Expr \rangle;\ \langle Iteration \rangle)\ \langle Body \rangle) \equiv & \\
&\langle Preambule \rangle\ \langle Expr \rangle\ \rho_{exit}\ !F\ \rho_{body}\ !\ \langle Iteration \rangle\ \rho_{return}\ !\ \langle Body \rangle\ \rho_{iteration}\ !& 
\end{aligned}
$$

Примеры:

$$
\begin{aligned}
&Poliz(for(i = 0;\ i < n;\ ++i) \text{\{} a = b - c;\ ++b;\}) \equiv & \\
&\eth i\ 0\ =\ ;\ i\ n\ <\ 28\ !F\ 17\ !\ \eth i\ +\nparallel\ ;\ 5\ !\ \eth a\ b\ c\ -\ =\ ;\ \eth b\ +\nparallel\ ;\ 12\ !&
\end{aligned}
$$

$$Poliz(for(;\ i < 10;\ ++i)); \equiv i\ 10\ <\ 15\ !F\ 13\ !\ \eth i\ +\nparallel\ ;\ 1\ !\ 8\ !$$ 
## Тернарный оператор и условные выражения

Для тернарной операции запись аналогична работе с `if-else` конструкцией, однако конечной точкой является не переход к следующему выражению, а использование выбранного значения: $Poliz(a = a < b\ ?\ a\ :\ b;) \equiv \eth a\ a\ b\ <\ 10\ !F\ a\ 11\ !\ b\ =\ ;$ 

Для условных выражений также используются `if-else` конструкции более сложного вида:
 + $Poliz(\langle E_1 \rangle\ \eth \eth \ \langle E_2 \rangle) \equiv \langle E_1 \rangle\ 10\ !F\ \langle E_2 \rangle\ 10\ !F\ \textbf{True}\ 11\ !\ \textbf{False}$ 
 + $Poliz(\langle E_1 \rangle\ \vert\vert\ \langle E_2 \rangle) \equiv \langle E_1 \rangle\ 6\ !F\ 9\ !\ \langle E_2 \rangle\ 12\ !F\ \textbf{True}\ 13\ !\ \textbf{False}$

