При работе с трансляцией данных вообще и языками программирования в частности всегда возникает вопрос о самом механизме преобразования входной последовательности (будь то какие-то данные или исходный код программы) в итоговый информационный поток. Теория формальных языков, о некоторых разделах которой пойдёт дальше речь, описывает научный подход к решению данного вопроса.

# "Немного бла-бла" (с) FrBrGeorge

Что касается трансляции кода и работы компилятора и интерпретатора, преобразующих исходный текст языка программирования в двоичные машинные команды, механизм несложный. \
Упрощённо этот механизм трансляции можно описать так: изначально строка кода разбивается на **лексемы** - пары вида <последовательность символов ; тип элемента>. Типом может выступать константа, переменная, ключевое слово языка, символ операции и т.д. После этого строится **абстрактное синтаксическое дерево**, описывающее зависимости лексем и, тем самым, выстраивающее логику программы. На основе дерева собирается **трёхадресный код**, а также **таблица символов**, соотносящая данные из программы с их именованием в трёхадресном коде; на этом этапе происходит процесс оптимизации программы. После этого итоговые трёхадресные инструкции переводятся в машинный код и отправляются на исполнение в случае интерпретатора или записываются в исполняемый файл в случае компилятора.

В рамках курса "Системы Программирования" в 4ом семестре погружение останавливается на этапе построения АСД (причём в отрыве от компиляторной привязки; как и любая наука, она разбирается на общих примерах и механизмах типа конечных автоматов), в 6ом семестре на третьем потоке в рамках курса "Формальный Языки и Автоматы" идёт развитие этой темы, в 7ом семестре в рамках курса "Конструирование Компиляторов" разбирается трёхадресный код и оптимизационные алгоритмы компилятора.

# Теорминчик

Для более точного понимания всех терминов, используемых в дальнейшем (да и вообще для понимания происходящего), рекомендуется пользоваться [методичкой](https://docs.yandex.ru/docs/view?tm=1729342701&tld=ru&lang=ru&name=3-formalnye_grammatiki_i_jazyki-vmik_mgu-2009.pdf&text=%D0%B2%D0%BE%D0%BB%D0%BA%D0%BE%D0%B2%D0%B0%20%D0%B2%D0%BC%D0%BA%20%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8&url=https%3A%2F%2Fvmk.ucoz.net%2FFiles%2Fit%2FInformatics%2F3-formalnye_grammatiki_i_jazyki-vmik_mgu-2009.pdf&lr=21735&mime=pdf&l10n=ru&sign=a6213ca3cb10849b89bf96e0572e1a70&keyno=0&nosw=1&serpParams=tm%3D1729342701%26tld%3Dru%26lang%3Dru%26name%3D3-formalnye_grammatiki_i_jazyki-vmik_mgu-2009.pdf%26text%3D%25D0%25B2%25D0%25BE%25D0%25BB%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25B0%2B%25D0%25B2%25D0%25BC%25D0%25BA%2B%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B5%2B%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B8%26url%3Dhttps%253A%2F%2Fvmk.ucoz.net%2FFiles%2Fit%2FInformatics%2F3-formalnye_grammatiki_i_jazyki-vmik_mgu-2009.pdf%26lr%3D21735%26mime%3Dpdf%26l10n%3Dru%26sign%3Da6213ca3cb10849b89bf96e0572e1a70%26keyno%3D0%26nosw%3D1&clckid=29be6379). В частности, на первых двух страницах повествования указаны все обозначения, которые будут появляться в главах. Однако самые важные мы продублируем и здесь (некоторые термины **изменены** и не являются добуквенно верными, однако передают свой смысл и изменены именно для упрощения понимания происходящего).

Основной объект нашего исследования - ***формальная (порождающая) грамматика***. Это четвёрка вида `G = <T, N, P, S>`, где:
 + `T` - множество терминальных символов (терминалов);
 + `N` - Множество нетерминальных символов (нетерминалов);
 + `P` - Множество правил вида $\alpha \rightarrow \beta$ (где $\alpha \in (T \cup N)^+$ и содержит минимум один нетерминал, $\beta \in (T \cup N)^*$ ), описывающих преобразования в грамматике;
 + `S` $\in$ `N` - начальный нетерминал.

Грамматику можно использовать для двух задач: задачи **построения языка грамматики** (Определить все возможные слова, состоящие только из терминальных символов, которые можно получить с помощью этой грамматики из начального нетерминала) и задачи **определения принадлежности некоторого слова грамматике** (Определить, возможно ли получить из начального нетерминала данное терминальное слово).

\*Именно поэтому слово "порождающая" взято в скобки. Вторая задача изначально может оказаться неочевидной, если анализировать грамматику исключительно как генератор, а не как проверяльщик некоторого элемента, описываемого некими терминальными свойствами.\*

По структуре формальная грамматика похожа на НАМ. Отличие заключается в том, что в НАМ на каждом шаге выбирается первое сверху подходящее правило, тогда как для грамматики правила могут выбираться в любом порядке, соответственно выстраиваемый грамматикой язык разрастается деревом вариантов из начального нетерминала. Ещё одно отличие НАМ и грамматик - наличие двух алфавитов символов и работа с ними в отличие от единого алфавита НАМ. Логически два алфавита можно воспринимать как наборы функций некоторой системы, которые в процессе исполнения рекурсивно вызывают другие функции и/или генерируют проверочные данные для проверки корректности алгоритма.

Пример грамматики:
```shell
S -> 0S1 | 0A1 # Для множества правил с одинаковой левой частью можно писать правые части через разделитель (т.е. здесьдва правила)
A -> 0A1 | e # Преобразование может производиться в том числе и в пустую строку
```

Для такой грамматики довольно просто построить порождаемый ею язык. Достаточно построить пример получения одного из слов и заметить закономерность: `S -> 0S1 -> 00A11 -> 0011`. L(G) = { $0^n1^n\ |\ n > 0$ }.