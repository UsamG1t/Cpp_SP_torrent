# Немного вводных

В прошлой главе был рассмотрен случай разбора языка, описываемого в виде автоматных грамматик. Такой механизм подходит для довольно узкого класса задач, в которых все действия последовательны и зависят в каждый период времени лишь от какого-то одного фактора. На практике же чаще встречаются схемы, в которых зависимости являются многокритериальными, почти все языки программирования описываются структурами в виде множества рекурсивных зависящих друг от друга элементов.

Например, программа на С++ должна для работы иметь функцию `main` с явно выделенным телом (окружённым фигурными скобочками), в теле которой описана логика программы. При этом у `main` могут быть параметры, наличие или отсутствие которых также необходимо отслеживать и обрабатывать. Перекладывая это правило на язык формальных грамматик мы получим вот такую  структуру:

```
main -> argc argv MainBody | NoArgsMainBody
NoArgcMainBody -> 1 NULL MainBody
MainBody -> { MainProgramm }
MainProgramm -> ...
...
```

Таким образом, для покрытия множества возможных структур программ подходят ***Контекстно-Свободные грамматики***. Для работы с ними и установки, имеет ли цепочка лексем структуру, заданную синтаксисом языка, используется **синтаксический анализатор**. \
Справедливости ради, способность лексического анализатора разбирать цепочки на корректность это не совсем верное утверждение. Проверкой корректности структуры занимается именно синтаксический анализатор, просто восходящий разбор с помощью ДКА стараются выделить отдельно от более общего метода, которым оперирует анализатор для КС-грамматик, не являющихся автоматными грамматиками.

# Метод рекурсивного спуска

Из примера выше видно, что нетерминалы получившейся грамматики подобно вложенным функциям описаны друг в друге. Действительно, КС-грамматику можно соотнести с программой, рекурсивно вызывающей некоторые функциональные элементы соответственно некоторому набору состояний системы. В рамках такой интерпретации проверка принадлежности некоторой цепочки языку соответствует корректному исполнению некоторой рекурсивной программы, в которой элементы и правила выбора следующего шага обрабатываются вглубь рекурсии слева направо. Данный метод проверки называется ***Методом рекурсивного спуска***.

Рассмотрим пример грамматики и реализуем описывающую её программу на С++:

```
M -> S _|_
S -> ABd
A -> a | cA
B -> bA
```

```cpp
#include <iostream>

char c;
void gc() {std::cin >> std::noskipws >> c;}

void S() {
	A();
	B();
	if (c != 'd') throw c;
	gc();
}

void A() {
	if (c == 'a') {
		gc();
	} else if (c == 'c') {
		gc();
		A();
	} else {
		throw c;
	}
}

void B() {
	if (c == 'b') {
		gc();
		A();
	} else {
		throw c;
	}
}

int main() {
	try {
		gc();
		S();
		if (c != '_|_') throw c;
	}
	catch (char c) {std::cout << "Uncorrect symbol " << c << std::endl;}
	return 0;
}
```

# Применимость метода рекурсивного спуска

Далеко не к каждой грамматике возможно применить метод рекурсивного спуска. Это может быть связано с недетерминированным поведением грамматики аналогично недетерминированным конечным автоматам для регулярных грамматик.

Вообще говоря, КС-грамматики тоже описываются автоматами, но не простыми, а **магазинными**. Они характеризуются дополнительным стеком памяти и переходами не только по текущему символу входной строки, но и по верхнему символу магазина. Но, в отличие от обычного НКА, недетерминированный магазинный автомат не приводится к детерминированному, по крайней мере, без нарушения языка. Поэтому необходимо уметь определять применимость метода рекурсивного спуска для исследования принадлежности цепочек КС-грамматикам.

---

### S-грамматики

Первый тип грамматик, к которым применин рекурсивный спуск, называется ***S-грамматики***. Они характеризуются правилами с детерминированными переходами благодаря различным начальным терминалам правой части:

$$
\begin{aligned}
	&1.\ X \rightarrow \alpha, \alpha \in (T \cup N)^*& \\
	&2.\ X \rightarrow a_1\alpha_1 | a_2\alpha_2 | \dots | a_n\alpha_n,\ a_i \neq a_j\ при\ i \neq j
\end{aligned}
$$

---

S-грамматики задают класс детерминированных неукорачивающих грамматик (вернее, близких к ним; ограничения на пустую правую часть чуть ослаблены, и в S-грамматиках её можно обнаружить не только у начального нетерминала (при этом важно, что других правил для этого нетерминала в левой части **не существует**)). На практике же могут встречаться грамматики, к которым применим рекурсивный спуск, но для которых правило с пустой правой частью не является единственным для заданного нетерминала. \
С точки зрения построения программы обработка пустой правой части просто пропускает обработку текущего символа цепочки, как бы пробрасывая его дальше по программе:

```
A -> aA | bB | \epsilon
```

```cpp
void A() {
if (c == 'a') {
	gc();
	A();
} else if (c == 'b') {
	gc();
	B();
}
// if no term, do nothing
}
```

С точки зрения грамматики работа с пустой правой частью не так очевидна. Рассмотрим пример грамматики, не поддающейся разбору с помощью рекурсивного спуска:

```
S -> bAa
A -> aA | \epsilon
```

```cpp
void S() {
	gc();
	if (c != 'b') {
		throw c;
	}
	gc();
	A();
	if (c != 'a') {
		throw c;
	}
	gc();
}

void A() {
	if (c == 'a') {
		gc();
		A();
	}
	// no term, do nothing
}
```

Допустим, на вход была подана цепочка `baaa`. Программа обрабатывает цепочку посимвольно, постараемся проследить логику разбора методом рекурсивного спуска:
 + Первый считанный терминал - `b`, всё корректно, продолжаем работу, переходя в функцию `A()`;
 + Второй, третий и четвёртый терминалы -  `a`, программа считывает их и рекурсивно вызывает функцию `A()`;
 + Программа получает пустой символ, условие не выполнено, функция `A()` (и её вызовы выше по стеку) рекурсивно завершается, происходит выход на уровень функции `S()`;
 + Происходит проверка пустого символа, она проваливается, программа считается неуспешной, а строчка - непринадлежащей языку, хотя для нас её принадлежность очевидна;

Несоответствие связано с особыми ограничениями, накладываемыми пустой правой частью на правила для того же нетерминала. Для определения нового типа грамматик с заданными ограничениями необходимо ввести два специальных множества:
 + $first(\alpha)$ = \{ $a \in T\ |\ \alpha \Rightarrow a\omega, \omega \in T^*$ \} - множество таких терминальных символов, с которым начинаются все выводимые (не обязательно за одно действие) из $\alpha \in (T \cup N)^*$ терминальные цепочки;
 + $follow(A)$ = \{ $a \in T\ |\ S \Rightarrow \alpha A a \beta;\ \alpha, \beta \in (t \cup N)^*$ \} - множество таких терминальных символов, которые следуют в цепочке преобразований от начального нетерминала сразу после нетерминала $A \in N$;

### Q-грамматики

Второй тип грамматик, к которым применин рекурсивный спуск, называется ***Q-грамматики***. Они описывают правила для недетерминированных МП-автоматов с правилами с пустой правой частью:

$$
\begin{aligned}
	&1.\ X \rightarrow \alpha, \alpha \in (T \cup N)^*& \\
	&2.\ X \rightarrow a_1\alpha_1 | a_2\alpha_2 | \dots | a_n\alpha_n,\ a_i \neq a_j\ при\ i \neq j \\
	&3.\ X \rightarrow a_1\alpha_1 | a_2\alpha_2 | \dots | a_n\alpha_n | \epsilon,\ first(X) \cap follow(X) = \varnothing
\end{aligned}
$$

Примеры:

```
S -> aSB | bAf | \epsilon
A -> bAc | cS
B -> cB | d
```

Правила для нетерминалов `A`и `B` подчиняются 2-ому правилу Q-грамматик. Проверим правила для `S`:
 + $first(S)$ = \{ a, b \};
 + $follow(S)$ = \{ c, d, f \}, т.к. существуют выводы:
	 + `S` -> `aSB` -> `aScB`
	 + `S` -> `aSB` -> `aSd`
	 + `S` -> `bAf` -> `bcSf`
 + $first(S) \cup follow(S) = \varnothing$, правила для `S` удовлетворяют 3-ему правилу Q-грамматик
К данной грамматике применим рекурсивный спуск. 

```
S -> bSB | a
A -> a | \epsilon
B -> aA | cBb
```

Правила для нетерминалов `S`и `B` подчиняются 2-ому правилу Q-грамматик. Проверим правила для `A`:
 + $first(A)$ = \{ a \};
 + $follow(A)$ = \{ a, b, c \}, т.к. существуют выводы:
	 + `S` -> `bSB` -> `bbSBB` -> `bbSaAB` -> `bbSaAaA`
	 + `S` -> `bSB` -> `bbSBB` -> `bbSaAB` -> `bbSaAcBb`
	 + `S` -> `bSB` -> `bScBc` -> `bScaAb`
 + $first(A) \cup follow(A) \neq \varnothing$, правила для `A` **не** удовлетворяют 3-ему правилу Q-грамматик
К данной грамматике **не** применим рекурсивный спуск.

---

### Критерий применимости рекурсивного спуска

Для определения применимости метода рекурсивного спуска существует **универсальный критерий применимости**:

Рассматриваются все возможные пары правил вида: $X \rightarrow \alpha\ |\ \beta$.
1. Для каждой пары правил должно быть верно: $first(\alpha) \cap first(\beta) = \varnothing$;
2. Не более чем одно из правил может иметь пустой вывод:
    + Либо $\alpha \Rightarrow \epsilon$;
    + Либо $\beta \Rightarrow \epsilon$;
    + Либо никто из них не имеет вывода в $\epsilon$
3. Если $\beta \Rightarrow \epsilon$, то $first(\alpha) \cap follow(X) = \varnothing$

При выполнении **всех трёх условий** для **каждой пары правил** к грамматике применин рекурсивный спуск.

Пример использования алгоритма:

```
S -> ABc | c
A -> aA | \epsilon
B -> bB | \epsilon
```

Для пары правил `S -> ABc | c` не выполняется первое условие, поскольку:
 + $first(c)$ = c 
 + $first(ABc)$ = \{ a, b, c \}, тк из этой цепочки получаются, например, такие терминальные цепочки:
	 + `ABc` -> `aABc` -> `a \epsilon Bc` -> `a \epsilon \epsilon c` $\equiv$ `ac`
	 + `ABc` -> `AbBc` -> `\epsilon bBc` -> `\epsilon b \epsilon c` $\equiv$ `bc`
	 + `ABc` -> `\epsilon Bc` -> `\epsilon \epsilon c` $\equiv$ `c`
 + $first(c) \cap first(ABc) \neq \varnothing$
